{
  "version": 3,
  "sources": ["../../../core/embedjs-interfaces/src/interfaces/base-loader.ts", "../../../core/embedjs-interfaces/src/interfaces/base-embeddings.ts", "../../../core/embedjs-interfaces/src/interfaces/base-model.ts", "../../../core/embedjs-interfaces/src/types.ts", "../../../core/embedjs-interfaces/src/constants.ts", "../../../core/embedjs-interfaces/src/index.ts", "../../../core/embedjs-utils/src/util/arrays.ts", "../../../core/embedjs-utils/src/util/log.ts", "../../../core/embedjs-utils/src/util/stream.ts", "../../../core/embedjs-utils/src/util/strings.ts", "../../../core/embedjs-utils/src/util/web.ts", "../../../core/embedjs-utils/src/index.ts", "../../../models/embedjs-openai/src/openai-model.ts", "../../../models/embedjs-openai/src/azure-openai-model.ts", "../../../models/embedjs-openai/src/azure-openai-embeddings.ts", "../../../models/embedjs-openai/src/openai-embeddings.ts", "../../../models/embedjs-openai/src/index.ts", "../../../loaders/embedjs-loader-web/src/web-loader.ts", "../../../loaders/embedjs-loader-web/src/index.ts", "../../../examples/confluence/src/main.ts", "../../../core/embedjs/src/core/rag-application.ts", "../../../core/embedjs/src/core/rag-application-builder.ts", "../../../core/embedjs/src/store/memory-store.ts", "../../../core/embedjs/src/loaders/local-path-loader.ts", "../../../core/embedjs/src/util/mime.ts", "../../../core/embedjs/src/loaders/text-loader.ts", "../../../core/embedjs/src/loaders/json-loader.ts", "../../../core/embedjs/src/loaders/url-loader.ts", "../../../core/embedjs/src/index.ts", "../../../databases/embedjs-libsql/src/libsql-db.ts", "../../../databases/embedjs-libsql/src/libsql-store.ts", "../../../loaders/embedjs-loader-confluence/src/confluence-loader.ts"],
  "sourcesContent": ["import md5 from 'md5';\r\nimport createDebugMessages from 'debug';\r\nimport { EventEmitter } from 'node:events';\r\n\r\nimport { BaseStore } from './base-store.js';\r\nimport { LoaderChunk, UnfilteredLoaderChunk } from '../types.js';\r\nimport { BaseModel } from './base-model.js';\r\n\r\nexport abstract class BaseLoader<\r\n    MetadataTemplate extends Record<string, string | number | boolean> = Record<string, string | number | boolean>,\r\n    CacheTemplate extends Record<string, unknown> = Record<string, unknown>,\r\n> extends EventEmitter {\r\n    private static store: BaseStore;\r\n\r\n    public static setCache(store: BaseStore) {\r\n        BaseLoader.store = store;\r\n    }\r\n\r\n    protected readonly uniqueId: string;\r\n    protected readonly chunkSize: number;\r\n    protected readonly chunkOverlap: number;\r\n    public readonly canIncrementallyLoad: boolean;\r\n    protected readonly loaderMetadata: Record<string, unknown>;\r\n\r\n    constructor(\r\n        uniqueId: string,\r\n        loaderMetadata: Record<string, unknown>,\r\n        chunkSize = 5,\r\n        chunkOverlap = 0,\r\n        canIncrementallyLoad = false,\r\n    ) {\r\n        super();\r\n\r\n        this.uniqueId = uniqueId;\r\n        this.chunkSize = chunkSize;\r\n        this.chunkOverlap = chunkOverlap;\r\n        this.loaderMetadata = loaderMetadata;\r\n        this.canIncrementallyLoad = canIncrementallyLoad;\r\n\r\n        createDebugMessages('embedjs:loader:BaseLoader')(`New loader class initalized with key ${uniqueId}`);\r\n    }\r\n\r\n    public getUniqueId(): string {\r\n        return this.uniqueId;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    public async init(): Promise<void> {}\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars\r\n    public injectModel(_model: BaseModel) {}\r\n\r\n    private async recordLoaderInCache(chunksProcessed: number) {\r\n        if (!BaseLoader.store) return;\r\n\r\n        const loaderData = {\r\n            uniqueId: this.uniqueId,\r\n            type: this.constructor.name,\r\n            loaderMetadata: this.loaderMetadata,\r\n            chunksProcessed,\r\n        };\r\n\r\n        await BaseLoader.store.addLoaderMetadata(this.uniqueId, loaderData);\r\n    }\r\n\r\n    private getCustomCacheKey(key: string) {\r\n        return `LOADER_CUSTOM_${this.uniqueId}_${key}`;\r\n    }\r\n\r\n    protected async checkInCache(key: string) {\r\n        if (!BaseLoader.store) return false;\r\n        return BaseLoader.store.loaderCustomHas(this.getCustomCacheKey(key));\r\n    }\r\n\r\n    protected async getFromCache(key: string): Promise<CacheTemplate> {\r\n        if (!BaseLoader.store) return null;\r\n        return BaseLoader.store.loaderCustomGet(this.getCustomCacheKey(key));\r\n    }\r\n\r\n    protected async saveToCache(key: string, value: CacheTemplate) {\r\n        if (!BaseLoader.store) return;\r\n        await BaseLoader.store.loaderCustomSet(this.uniqueId, this.getCustomCacheKey(key), value);\r\n    }\r\n\r\n    protected async deleteFromCache(key: string) {\r\n        if (!BaseLoader.store) return false;\r\n        return BaseLoader.store.loaderCustomDelete(this.getCustomCacheKey(key));\r\n    }\r\n\r\n    protected async loadIncrementalChunk(\r\n        incrementalGenerator: AsyncGenerator<LoaderChunk<MetadataTemplate>, void, void>,\r\n    ) {\r\n        this.emit('incrementalChunkAvailable', incrementalGenerator);\r\n    }\r\n\r\n    /**\r\n     * This TypeScript function asynchronously processes chunks of data, cleans up the content,\r\n     * calculates a content hash, and yields the modified chunks.\r\n     */\r\n    public async *getChunks(): AsyncGenerator<LoaderChunk<MetadataTemplate>, void, void> {\r\n        const chunks = await this.getUnfilteredChunks();\r\n\r\n        let count = 0;\r\n        for await (const chunk of chunks) {\r\n            chunk.pageContent = chunk.pageContent\r\n                .replace(/(\\r\\n|\\n|\\r)/gm, ' ')\r\n                .replace(/\\s\\s+/g, ' ')\r\n                .trim();\r\n\r\n            if (chunk.pageContent.length > 0) {\r\n                yield {\r\n                    ...chunk,\r\n                    contentHash: md5(chunk.pageContent),\r\n                };\r\n                count++;\r\n            }\r\n        }\r\n\r\n        await this.recordLoaderInCache(count);\r\n    }\r\n\r\n    abstract getUnfilteredChunks(): AsyncGenerator<UnfilteredLoaderChunk<MetadataTemplate>, void, void>;\r\n}\r\n", "export abstract class BaseEmbeddings {\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    public async init(): Promise<void> {}\r\n\r\n    public abstract embedDocuments(texts: string[]): Promise<number[][]>;\r\n    public abstract embedQuery(text: string): Promise<number[]>;\r\n    public abstract getDimensions(): Promise<number>;\r\n}\r\n", "import { HumanMessage, AIMessage, SystemMessage } from '@langchain/core/messages';\r\nimport createDebugMessages from 'debug';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nimport { Chunk, QueryResponse, Message, SourceDetail, ModelResponse, Conversation } from '../types.js';\r\nimport { BaseStore } from './base-store.js';\r\n\r\nexport abstract class BaseModel {\r\n    private readonly baseDebug = createDebugMessages('embedjs:model:BaseModel');\r\n\r\n    private static store: BaseStore;\r\n    private static defaultTemperature: number;\r\n\r\n    public static setDefaultTemperature(temperature?: number) {\r\n        BaseModel.defaultTemperature = temperature;\r\n    }\r\n\r\n    public static setStore(cache: BaseStore) {\r\n        BaseModel.store = cache;\r\n    }\r\n\r\n    private readonly _temperature?: number;\r\n\r\n    constructor(temperature?: number) {\r\n        this._temperature = temperature;\r\n    }\r\n\r\n    public get temperature() {\r\n        return this._temperature ?? BaseModel.defaultTemperature;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\r\n    public async init(): Promise<void> {}\r\n\r\n    private extractUniqueSources(supportingContext: Chunk[]): SourceDetail[] {\r\n        const uniqueSources = new Map<string, SourceDetail>(); // Use a Map to track unique sources by URL\r\n\r\n        supportingContext.forEach((item) => {\r\n            const { metadata } = item;\r\n            if (metadata && metadata.source) {\r\n                // Use the source URL as the key to ensure uniqueness\r\n                if (!uniqueSources.has(metadata.source)) {\r\n                    uniqueSources.set(metadata.source, {\r\n                        source: metadata.source,\r\n                        loaderId: metadata.uniqueLoaderId, // Assuming this field always exists\r\n                    });\r\n                }\r\n            }\r\n        });\r\n\r\n        // Convert the values of the Map to an array\r\n        return Array.from(uniqueSources.values());\r\n    }\r\n\r\n    public async prepare(\r\n        system: string,\r\n        userQuery: string,\r\n        supportingContext: Chunk[],\r\n        pastConversations: Message[],\r\n    ): Promise<(AIMessage | SystemMessage | HumanMessage)[]> {\r\n        const messages: (AIMessage | SystemMessage | HumanMessage)[] = [new SystemMessage(system)];\r\n        messages.push(\r\n            new SystemMessage(`Supporting context: ${supportingContext.map((s) => s.pageContent).join('; ')}`),\r\n        );\r\n\r\n        messages.push(\r\n            ...pastConversations.map((c) => {\r\n                if (c.actor === 'AI') return new AIMessage({ content: c.content });\r\n                else if (c.actor === 'SYSTEM') return new SystemMessage({ content: c.content });\r\n                else return new HumanMessage({ content: c.content });\r\n            }),\r\n        );\r\n        messages.push(new HumanMessage(`${userQuery}?`));\r\n        return messages;\r\n    }\r\n\r\n    public async query(\r\n        system: string,\r\n        userQuery: string,\r\n        supportingContext: Chunk[],\r\n        conversationId?: string,\r\n        limitConversation?: number,\r\n        callback?: any,\r\n        estimateTokens?: (text: string) => number,\r\n    ): Promise<QueryResponse> {\r\n        let conversation: Conversation;\r\n\r\n        if (conversationId) {\r\n            if (!(await BaseModel.store.hasConversation(conversationId))) {\r\n                this.baseDebug(`Conversation with id '${conversationId}' is new`);\r\n                await BaseModel.store.addConversation(conversationId);\r\n            }\r\n\r\n            conversation = await BaseModel.store.getConversation(conversationId);\r\n            this.baseDebug(\r\n                `${conversation.entries.length} history entries found for conversationId '${conversationId}'`,\r\n            );\r\n\r\n            //if we have short context windows we need to limit the conversation history\r\n            if (limitConversation && conversation.entries.length > 0) {\r\n                let userQueryTokens = estimateTokens(userQuery);\r\n                let text = '';\r\n                for (let i = 0; i < conversation.entries.length - 1; i++) {\r\n                    let c = conversation.entries[i];\r\n                    text = text + c.actor + ': ' + c.content + '\\n';\r\n                }\r\n                let tokenCount = estimateTokens(text);\r\n                while (conversation.entries.length > 0 && tokenCount + userQueryTokens > limitConversation) {\r\n                    conversation.entries.shift();\r\n                    text = '';\r\n                    for (let i = 0; i < conversation.entries.length - 1; i++) {\r\n                        let c = conversation.entries[i];\r\n                        text = text + c.actor + ': ' + c.content + '\\n';\r\n                    }\r\n                    tokenCount = estimateTokens(text);\r\n                }\r\n            }\r\n\r\n            // Add user query to history\r\n            await BaseModel.store.addEntryToConversation(conversationId, {\r\n                id: uuidv4(),\r\n                timestamp: new Date(),\r\n                actor: 'HUMAN',\r\n                content: userQuery,\r\n            });\r\n        } else {\r\n            this.baseDebug('Conversation history is disabled as no conversationId was provided');\r\n            conversation = { conversationId: 'default', entries: [] };\r\n        }\r\n\r\n        const messages = await this.prepare(system, userQuery, supportingContext, conversation.entries.slice(0, -1));\r\n        const uniqueSources = this.extractUniqueSources(supportingContext);\r\n        const timestamp = new Date();\r\n        const id = uuidv4();\r\n\r\n        // Run LLM implementation in subclass\r\n        const response = await this.runQuery(messages, callback);\r\n\r\n        const newEntry: Message = {\r\n            id,\r\n            timestamp,\r\n            content: response.result,\r\n            actor: 'AI',\r\n            sources: uniqueSources,\r\n        };\r\n\r\n        if (conversationId) {\r\n            // Add AI response to history\r\n            await BaseModel.store.addEntryToConversation(conversationId, newEntry);\r\n        }\r\n\r\n        return {\r\n            ...newEntry,\r\n            tokenUse: {\r\n                inputTokens: response.tokenUse?.inputTokens ?? 'UNKNOWN',\r\n                outputTokens: response.tokenUse?.outputTokens ?? 'UNKNOWN',\r\n            },\r\n        };\r\n    }\r\n\r\n    public async simpleQuery(messages: (AIMessage | SystemMessage | HumanMessage)[]) {\r\n        const response = await this.runQuery(messages);\r\n\r\n        return {\r\n            result: response.result,\r\n            tokenUse: {\r\n                inputTokens: response.tokenUse?.inputTokens ?? 'UNKNOWN',\r\n                outputTokens: response.tokenUse?.outputTokens ?? 'UNKNOWN',\r\n            },\r\n        };\r\n    }\r\n\r\n    protected abstract runQuery(\r\n        messages: (AIMessage | SystemMessage | HumanMessage)[],\r\n        callback?: any,\r\n    ): Promise<ModelResponse>;\r\n}\r\n", "export type LoaderMetadata<T> = T & { source: string };\r\nexport type LoaderChunk<\r\n    Meta extends Record<string, string | number | boolean> = Record<string, string | number | boolean>,\r\n> = {\r\n    pageContent: string;\r\n    contentHash: string;\r\n    metadata: LoaderMetadata<Meta>;\r\n};\r\nexport type UnfilteredLoaderChunk<\r\n    Meta extends Record<string, string | number | boolean> = Record<string, string | number | boolean>,\r\n> = {\r\n    pageContent: string;\r\n    metadata: LoaderMetadata<Meta>;\r\n};\r\n\r\nexport type Metadata<T> = T & { id: string; uniqueLoaderId: string; source: string };\r\nexport type Chunk<Meta extends Record<string, string | number | boolean> = Record<string, string | number | boolean>> =\r\n    {\r\n        pageContent: string;\r\n        metadata: Metadata<Meta>;\r\n    };\r\n\r\nexport type InsertChunkData<\r\n    Meta extends Record<string, string | number | boolean> = Record<string, string | number | boolean>,\r\n> = {\r\n    vector: number[];\r\n    pageContent: string;\r\n    metadata: Metadata<Meta>;\r\n};\r\n\r\nexport type ExtractChunkData<\r\n    Meta extends Record<string, string | number | boolean> = Record<string, string | number | boolean>,\r\n> = {\r\n    score: number;\r\n    pageContent: string;\r\n    metadata: Metadata<Meta>;\r\n};\r\n\r\nexport type AddLoaderReturn = { entriesAdded: number; uniqueId: string; loaderType: string };\r\n\r\nexport type SourceDetail = {\r\n    loaderId: string;\r\n    source: string;\r\n};\r\n\r\nexport type LoaderListEntry = {\r\n    type: string;\r\n    uniqueId: string;\r\n    chunksProcessed: number;\r\n    loaderMetadata: Record<string, unknown>;\r\n};\r\n\r\nexport type Message = {\r\n    id: string;\r\n    timestamp: Date;\r\n    content: string;\r\n} & (\r\n    | {\r\n          actor: 'HUMAN' | 'SYSTEM';\r\n      }\r\n    | {\r\n          actor: 'AI';\r\n          sources: SourceDetail[];\r\n      }\r\n);\r\n\r\nexport type Conversation = {\r\n    conversationId: string;\r\n    entries: Message[];\r\n};\r\n\r\nexport type ModelResponse = {\r\n    result: string;\r\n    tokenUse?: {\r\n        inputTokens: number;\r\n        outputTokens: number;\r\n    };\r\n};\r\n\r\nexport type QueryResponse = Extract<Message, { actor: 'AI' }> & {\r\n    tokenUse: {\r\n        inputTokens: number | 'UNKNOWN';\r\n        outputTokens: number | 'UNKNOWN';\r\n    };\r\n};\r\n", "export const DEFAULT_INSERT_BATCH_SIZE = 500;\r\n\r\nexport enum SIMPLE_MODELS {\r\n    'OPENAI_GPT3.5_TURBO',\r\n    'OPENAI_GPT4_TURBO',\r\n    'OPENAI_GPT4_O',\r\n}\r\n", "import { BaseLoader } from './interfaces/base-loader.js';\r\nimport { BaseVectorDatabase } from './interfaces/base-vector-database.js';\r\nimport { BaseEmbeddings } from './interfaces/base-embeddings.js';\r\nimport { BaseStore } from './interfaces/base-store.js';\r\nimport { BaseModel } from './interfaces/base-model.js';\r\n\r\nexport * from './types.js';\r\nexport * from './constants.js';\r\nexport { BaseStore, BaseVectorDatabase, BaseLoader, BaseEmbeddings, BaseModel };\r\n", "export function mapAsync<T, U>(\r\n    array: T[],\r\n    callbackfn: (value: T, index: number, array: T[]) => Promise<U>,\r\n): Promise<U[]> {\r\n    return Promise.all(array.map(callbackfn));\r\n}\r\n\r\nexport async function filterAsync<T>(\r\n    array: T[],\r\n    callbackfn: (value: T, index: number, array: T[]) => Promise<boolean>,\r\n): Promise<T[]> {\r\n    const filterMap = await mapAsync(array, callbackfn);\r\n    return array.filter((_value, index) => filterMap[index]);\r\n}\r\n\r\nexport function createArrayChunks<T>(arr: T[], size: number) {\r\n    return Array.from({ length: Math.ceil(arr.length / size) }, (_v, i) => arr.slice(i * size, i * size + size));\r\n}\r\n\r\nexport function getUnique<T extends object>(array: Array<T>, K: string) {\r\n    const seen = {};\r\n    return array.filter(function (item) {\r\n        return Object.prototype.hasOwnProperty.call(seen, item[K]()) ? false : (seen[item[K]()] = true);\r\n    });\r\n}\r\n", "import util from 'util';\r\n\r\nexport function deepLog(obj: unknown) {\r\n    console.log(util.inspect(obj, { depth: null, colors: true, sorted: true, compact: false }));\r\n}\r\n", "import { Stream } from 'stream';\r\n\r\nexport async function streamToBuffer(stream: Stream): Promise<Buffer> {\r\n    return new Promise<Buffer>((resolve, reject) => {\r\n        const _buf = Array<Uint8Array>();\r\n\r\n        stream.on('data', (chunk) => _buf.push(chunk));\r\n        stream.on('end', () => resolve(Buffer.concat(_buf)));\r\n        stream.on('error', (err) => reject(`error converting stream - ${err}`));\r\n    });\r\n}\r\n\r\nexport async function streamToString(stream: Stream): Promise<string> {\r\n    return new Promise((resolve, reject) => {\r\n        const chunks = [];\r\n\r\n        stream.on('data', (chunk) => chunks.push(Buffer.from(chunk)));\r\n        stream.on('end', () => resolve(Buffer.concat(chunks).toString('utf8')));\r\n        stream.on('error', (err) => reject(`error converting stream - ${err}`));\r\n    });\r\n}\r\n\r\nexport function contentTypeToMimeType(contentType: string) {\r\n    if (!contentType) return contentType;\r\n    if (contentType.includes(';')) return contentType.split(';')[0];\r\n    else return contentType;\r\n}\r\n", "import { Message } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport function truncateCenterString(fullStr: string, strLen: number, separator?: string) {\r\n    if (fullStr.length <= strLen) return fullStr;\r\n\r\n    separator = separator || '...';\r\n\r\n    const sepLen = separator.length,\r\n        charsToShow = strLen - sepLen,\r\n        frontChars = Math.ceil(charsToShow / 2),\r\n        backChars = Math.floor(charsToShow / 2);\r\n\r\n    return fullStr.substr(0, frontChars) + separator + fullStr.substr(fullStr.length - backChars);\r\n}\r\n\r\nexport function cleanString(text: string) {\r\n    text = text.replace(/\\\\/g, '');\r\n    text = text.replace(/#/g, ' ');\r\n    text = text.replace(/\\. \\./g, '.');\r\n    text = text.replace(/\\s\\s+/g, ' ');\r\n    text = text.replace(/(\\r\\n|\\n|\\r)/gm, ' ');\r\n\r\n    return text.trim();\r\n}\r\n\r\nexport function stringFormat(template: string, ...args: string[]) {\r\n    return template.replace(/{(\\d+)}/g, function (match, number) {\r\n        return typeof args[number] != 'undefined' ? args[number] : match;\r\n    });\r\n}\r\n\r\nexport function historyToString(history: Message[]) {\r\n    return history.reduce((p: string, c: Message) => {\r\n        return p.concat(`${c.actor}: ${c.content}`);\r\n    }, '');\r\n}\r\n\r\nexport function toTitleCase(str: string) {\r\n    return str.replace(/\\w\\S*/g, function (txt) {\r\n        return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();\r\n    });\r\n}\r\n\r\nexport function isValidURL(candidateUrl: string) {\r\n    try {\r\n        const url = new URL(candidateUrl);\r\n        return url.protocol === 'http:' || url.protocol === 'https:';\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function isValidJson(str: string) {\r\n    try {\r\n        JSON.parse(str);\r\n        return true;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n", "import createDebugMessages from 'debug';\r\n\r\nconst DEFAULT_USER_AGENT =\r\n    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36';\r\n\r\ntype getSafeResponsePartial = {\r\n    headers: Headers;\r\n    statusCode: number;\r\n};\r\n\r\nexport async function getSafe(\r\n    url: string,\r\n    options: { headers?: Record<string, string>; format: 'text' },\r\n): Promise<{ body: string } & getSafeResponsePartial>;\r\nexport async function getSafe(\r\n    url: string,\r\n    options: { headers?: Record<string, string>; format: 'buffer' },\r\n): Promise<{ body: Buffer } & getSafeResponsePartial>;\r\nexport async function getSafe(\r\n    url: string,\r\n    options?: { headers?: Record<string, string>; format?: 'stream' },\r\n): Promise<{ body: NodeJS.ReadableStream } & getSafeResponsePartial>;\r\nexport async function getSafe(\r\n    url: string,\r\n    options?: { headers?: Record<string, string>; format?: 'text' | 'buffer' | 'stream' },\r\n): Promise<{ body: any } & getSafeResponsePartial> {\r\n    const headers = options?.headers ?? {};\r\n    headers['User-Agent'] = headers['User-Agent'] ?? DEFAULT_USER_AGENT;\r\n\r\n    const format = options?.format ?? 'stream';\r\n    const response = await fetch(url, { headers });\r\n    createDebugMessages('embedjs:util:getSafe')(`URL '${url}' returned status code ${response.status}`);\r\n    if (response.status !== 200) throw new Error(`Failed to fetch URL '${url}'. Got status code ${response.status}.`);\r\n\r\n    return {\r\n        body:\r\n            format === 'text'\r\n                ? await response.text()\r\n                : format === 'buffer'\r\n                  ? Buffer.from(await response.arrayBuffer())\r\n                  : (response.body as unknown as NodeJS.ReadableStream),\r\n        statusCode: response.status,\r\n        headers: response.headers,\r\n    };\r\n}\r\n", "export * from './util/arrays.js';\r\nexport * from './util/log.js';\r\nexport * from './util/stream.js';\r\nexport * from './util/strings.js';\r\nexport * from './util/web.js';\r\n", "import createDebugMessages from 'debug';\r\nimport { ChatOpenAI } from '@langchain/openai';\r\nimport { HumanMessage, AIMessage, SystemMessage } from '@langchain/core/messages';\r\nimport { BaseModel, ModelResponse } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class OpenAi extends BaseModel {\r\n    private readonly debug = createDebugMessages('embedjs:model:OpenAi');\r\n    private model: ChatOpenAI;\r\n\r\n    constructor(private readonly configuration: ConstructorParameters<typeof ChatOpenAI>[0]) {\r\n        super(configuration.temperature);\r\n    }\r\n\r\n    override async init(): Promise<void> {\r\n        this.model = new ChatOpenAI(this.configuration);\r\n    }\r\n\r\n    override async runQuery(\r\n        messages: (AIMessage | SystemMessage | HumanMessage)[],\r\n        callback?: any,\r\n    ): Promise<ModelResponse> {\r\n        this.debug('Executing OpenAI model with prompt -', messages[messages.length - 1].content);\r\n\r\n        if (callback) {\r\n            const stream = await this.model.stream(messages);\r\n\r\n            const chunks = [];\r\n            for await (const chunk of stream) {\r\n                chunks.push(chunk);\r\n                callback(chunk);\r\n            }\r\n\r\n            let res = chunks.join('');\r\n            return {\r\n                result: res,\r\n            };\r\n        } else {\r\n            const result = await this.model.invoke(messages);\r\n            this.debug('OpenAI response -', result);\r\n\r\n            return {\r\n                result: result.content.toString(),\r\n                tokenUse: {\r\n                    inputTokens: result.response_metadata.tokenUsage.promptTokens,\r\n                    outputTokens: result.response_metadata.tokenUsage.completionTokens,\r\n                },\r\n            };\r\n        }\r\n    }\r\n}\r\n", "import createDebugMessages from 'debug';\r\nimport { AzureChatOpenAI } from '@langchain/openai';\r\nimport { HumanMessage, AIMessage, SystemMessage } from '@langchain/core/messages';\r\nimport { BaseModel, ModelResponse } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class AzureOpenAi extends BaseModel {\r\n    private readonly debug = createDebugMessages('embedjs:model:OpenAi');\r\n    private model: AzureChatOpenAI;\r\n\r\n    constructor(private readonly configuration: ConstructorParameters<typeof AzureChatOpenAI>[0]) {\r\n        super(configuration.temperature);\r\n    }\r\n\r\n    override async init(): Promise<void> {\r\n        this.model = new AzureChatOpenAI(this.configuration);\r\n    }\r\n\r\n    override async runQuery(messages: (AIMessage | SystemMessage | HumanMessage)[]): Promise<ModelResponse> {\r\n        this.debug('Executing Azure OpenAI model with prompt -', messages[messages.length - 1].content);\r\n        const result = await this.model.invoke(messages);\r\n        this.debug('Azure OpenAI response -', result);\r\n\r\n        return {\r\n            result: result.content.toString(),\r\n            tokenUse: {\r\n                inputTokens: result.response_metadata.tokenUsage.promptTokens,\r\n                outputTokens: result.response_metadata.tokenUsage.completionTokens,\r\n            },\r\n        };\r\n    }\r\n}\r\n", "import { AzureOpenAIEmbeddings as LangchainAzureOpenAiEmbeddings } from '@langchain/openai';\r\nimport { BaseEmbeddings } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class AzureOpenAiEmbeddings extends BaseEmbeddings {\r\n    private model: LangchainAzureOpenAiEmbeddings;\r\n\r\n    constructor(private readonly configuration?: ConstructorParameters<typeof LangchainAzureOpenAiEmbeddings>[0]) {\r\n        super();\r\n        if (!this.configuration) this.configuration = {};\r\n        if (!this.configuration.model) this.configuration.model = 'text-embedding-3-small';\r\n\r\n        if (!this.configuration.dimensions) {\r\n            if (this.configuration.model === 'text-embedding-3-small') {\r\n                this.configuration.dimensions = 1536;\r\n            } else if (this.configuration.model === 'text-embedding-3-large') {\r\n                this.configuration.dimensions = 3072;\r\n            } else if (this.configuration.model === 'text-embedding-ada-002') {\r\n                this.configuration.dimensions = 1536;\r\n            } else {\r\n                throw new Error('You need to pass in the optional dimensions parameter for this model');\r\n            }\r\n        }\r\n\r\n        this.model = new LangchainAzureOpenAiEmbeddings(this.configuration);\r\n    }\r\n\r\n    override async getDimensions(): Promise<number> {\r\n        return this.configuration.dimensions;\r\n    }\r\n\r\n    override async embedDocuments(texts: string[]): Promise<number[][]> {\r\n        return this.model.embedDocuments(texts);\r\n    }\r\n\r\n    override async embedQuery(text: string): Promise<number[]> {\r\n        return this.model.embedQuery(text);\r\n    }\r\n}\r\n", "import { OpenAIEmbeddings } from '@langchain/openai';\r\nimport { BaseEmbeddings } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class OpenAiEmbeddings extends BaseEmbeddings {\r\n    private model: OpenAIEmbeddings;\r\n\r\n    constructor(private readonly configuration?: ConstructorParameters<typeof OpenAIEmbeddings>[0]) {\r\n        super();\r\n        if (!this.configuration) this.configuration = {};\r\n        if (!this.configuration.model) this.configuration.model = 'text-embedding-3-small';\r\n\r\n        if (!this.configuration.dimensions) {\r\n            if (this.configuration.model === 'text-embedding-3-small') {\r\n                this.configuration.dimensions = 1536;\r\n            } else if (this.configuration.model === 'text-embedding-3-large') {\r\n                this.configuration.dimensions = 3072;\r\n            } else if (this.configuration.model === 'text-embedding-ada-002') {\r\n                this.configuration.dimensions = 1536;\r\n            } else {\r\n                throw new Error('You need to pass in the optional dimensions parameter for this model');\r\n            }\r\n        }\r\n\r\n        this.model = new OpenAIEmbeddings(this.configuration);\r\n    }\r\n\r\n    override async getDimensions(): Promise<number> {\r\n        return this.configuration.dimensions;\r\n    }\r\n\r\n    override async embedDocuments(texts: string[]): Promise<number[][]> {\r\n        return this.model.embedDocuments(texts);\r\n    }\r\n\r\n    override async embedQuery(text: string): Promise<number[]> {\r\n        return this.model.embedQuery(text);\r\n    }\r\n}\r\n", "export * from './openai-model.js';\r\nexport * from './azure-openai-model.js';\r\nexport * from './azure-openai-embeddings.js';\r\nexport * from './openai-embeddings.js';\r\n", "import { RecursiveCharacterTextSplitter } from '@langchain/textsplitters';\r\nimport createDebugMessages from 'debug';\r\nimport { convert } from 'html-to-text';\r\nimport md5 from 'md5';\r\n\r\nimport { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { isValidURL, truncateCenterString, cleanString, getSafe } from '@llm-tools/embedjs-utils';\r\n\r\nexport class WebLoader extends BaseLoader<{ type: 'WebLoader' }> {\r\n    private readonly debug = createDebugMessages('embedjs:loader:WebLoader');\r\n    private readonly urlOrContent: string;\r\n    private readonly isUrl: boolean;\r\n\r\n    constructor({\r\n        urlOrContent,\r\n        chunkSize,\r\n        chunkOverlap,\r\n    }: {\r\n        urlOrContent: string;\r\n        chunkSize?: number;\r\n        chunkOverlap?: number;\r\n    }) {\r\n        super(`WebLoader_${md5(urlOrContent)}`, { urlOrContent }, chunkSize ?? 2000, chunkOverlap ?? 0);\r\n\r\n        this.isUrl = isValidURL(urlOrContent) ? true : false;\r\n        this.urlOrContent = urlOrContent;\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        const chunker = new RecursiveCharacterTextSplitter({\r\n            chunkSize: this.chunkSize,\r\n            chunkOverlap: this.chunkOverlap,\r\n        });\r\n\r\n        try {\r\n            const data = this.isUrl ? (await getSafe(this.urlOrContent, { format: 'text' })).body : this.urlOrContent;\r\n\r\n            const text = convert(data, {\r\n                wordwrap: false,\r\n                preserveNewlines: false,\r\n            }).replace(/(?:https?|ftp):\\/\\/[\\n\\S]+/g, '');\r\n\r\n            const tuncatedObjectString = this.isUrl ? undefined : truncateCenterString(this.urlOrContent, 50);\r\n\r\n            const chunks = await chunker.splitText(cleanString(text));\r\n            for (const chunk of chunks) {\r\n                yield {\r\n                    pageContent: chunk,\r\n                    metadata: {\r\n                        type: 'WebLoader' as const,\r\n                        source: this.isUrl ? this.urlOrContent : tuncatedObjectString,\r\n                    },\r\n                };\r\n            }\r\n        } catch (e) {\r\n            this.debug('Could not parse input', this.urlOrContent, e);\r\n        }\r\n    }\r\n}\r\n", "export { WebLoader } from './web-loader.js';\r\n", "import 'dotenv/config';\r\nimport path from 'node:path';\r\nimport { RAGApplicationBuilder } from '@llm-tools/embedjs';\r\nimport { LibSqlDb, LibSqlStore } from '@llm-tools/embedjs-libsql';\r\nimport { OpenAi, OpenAiEmbeddings } from '@llm-tools/embedjs-openai';\r\nimport { ConfluenceLoader } from '@llm-tools/embedjs-loader-confluence';\r\n\r\nconst databasePath = path.resolve('./examples/confluence/data.db');\r\nconst llmApplication = await new RAGApplicationBuilder()\r\n    .setStore(new LibSqlStore({ path: databasePath }))\r\n    .setVectorDatabase(new LibSqlDb({ path: databasePath }))\r\n    .setModel(new OpenAi({ modelName: 'gpt-4o' }))\r\n    .setEmbeddingModel(new OpenAiEmbeddings())\r\n    .build();\r\n\r\nawait llmApplication.addLoader(new ConfluenceLoader({ spaceName: 'DEMO' }));\r\nconsole.log(await llmApplication.query('Who founded Tesla?'));\r\n", "import createDebugMessages from 'debug';\r\n\r\nimport { RAGApplicationBuilder } from './rag-application-builder.js';\r\nimport {\r\n    AddLoaderReturn,\r\n    BaseLoader,\r\n    BaseModel,\r\n    BaseStore,\r\n    BaseVectorDatabase,\r\n    Chunk,\r\n    InsertChunkData,\r\n    LoaderChunk,\r\n    QueryResponse,\r\n    SIMPLE_MODELS,\r\n    DEFAULT_INSERT_BATCH_SIZE,\r\n    BaseEmbeddings,\r\n} from '@llm-tools/embedjs-interfaces';\r\nimport { cleanString, getUnique } from '@llm-tools/embedjs-utils';\r\n\r\nexport class RAGApplication {\r\n    private readonly debug = createDebugMessages('embedjs:core');\r\n    private readonly storeConversationsToDefaultThread: boolean;\r\n    private readonly embeddingRelevanceCutOff: number;\r\n    private readonly searchResultCount: number;\r\n    private readonly systemMessage: string;\r\n    private readonly vectorDatabase: BaseVectorDatabase;\r\n    private readonly embeddingModel: BaseEmbeddings;\r\n    private readonly store: BaseStore;\r\n    private loaders: BaseLoader[];\r\n    private model: BaseModel;\r\n\r\n    constructor(llmBuilder: RAGApplicationBuilder) {\r\n        if (!llmBuilder.getEmbeddingModel()) throw new Error('Embedding model must be set!');\r\n        this.embeddingModel = llmBuilder.getEmbeddingModel();\r\n\r\n        this.storeConversationsToDefaultThread = llmBuilder.getParamStoreConversationsToDefaultThread();\r\n        this.store = llmBuilder.getStore();\r\n        BaseLoader.setCache(this.store);\r\n        BaseModel.setStore(this.store);\r\n\r\n        this.systemMessage = cleanString(llmBuilder.getSystemMessage());\r\n        this.debug(`Using system query template - \"${this.systemMessage}\"`);\r\n\r\n        this.vectorDatabase = llmBuilder.getVectorDatabase();\r\n        if (!this.vectorDatabase) throw new SyntaxError('vectorDatabase not set');\r\n\r\n        this.searchResultCount = llmBuilder.getSearchResultCount();\r\n        this.embeddingRelevanceCutOff = llmBuilder.getEmbeddingRelevanceCutOff();\r\n    }\r\n\r\n    /**\r\n     * The function initializes various components of a language model using provided configurations\r\n     * and data. This is an internal method and does not need to be invoked manually.\r\n     * @param {RAGApplicationBuilder} llmBuilder - The `llmBuilder` parameter in the `init` function is\r\n     * an instance of the `RAGApplicationBuilder` class. It is used to build and configure a Language\r\n     * Model (LLM) for a conversational AI system. The function initializes various components of the\r\n     * LLM based on the configuration provided\r\n     */\r\n    public async init(llmBuilder: RAGApplicationBuilder) {\r\n        await this.embeddingModel.init();\r\n\r\n        this.model = await this.getModel(llmBuilder.getModel());\r\n        if (!this.model) this.debug('No base model set; query function unavailable!');\r\n        else BaseModel.setDefaultTemperature(llmBuilder.getTemperature());\r\n\r\n        this.loaders = llmBuilder.getLoaders();\r\n\r\n        if (this.model) {\r\n            await this.model.init();\r\n            this.debug('Initialized LLM class');\r\n        }\r\n\r\n        await this.vectorDatabase.init({ dimensions: await this.embeddingModel.getDimensions() });\r\n        this.debug('Initialized vector database');\r\n\r\n        if (this.store) {\r\n            await this.store.init();\r\n            this.debug('Initialized cache');\r\n        }\r\n\r\n        this.loaders = getUnique(this.loaders, 'getUniqueId');\r\n        for await (const loader of this.loaders) {\r\n            await this.addLoader(loader);\r\n        }\r\n        this.debug('Initialized pre-loaders');\r\n    }\r\n\r\n    /**\r\n     * The function getModel retrieves a specific BaseModel or SIMPLE_MODEL based on the input provided.\r\n     * @param {BaseModel | SIMPLE_MODELS | null} model - The `getModel` function you provided is an\r\n     * asynchronous function that takes a parameter `model` of type `BaseModel`, `SIMPLE_MODELS`, or\r\n     * `null`.\r\n     * @returns The `getModel` function returns a Promise that resolves to a `BaseModel` object. If the\r\n     * `model` parameter is an object, it returns the object itself. If the `model` parameter is\r\n     * `null`, it returns `null`. If the `model` parameter is a specific value from the `SIMPLE_MODELS`\r\n     * enum, it creates a new `BaseModel` object based on the model name.\r\n     */\r\n    private async getModel(model: BaseModel | SIMPLE_MODELS | null): Promise<BaseModel> {\r\n        if (typeof model === 'object') return model;\r\n        else if (model === null) return null;\r\n        else {\r\n            const { OpenAi } = await import('@llm-tools/embedjs-openai').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-openai` needs to be installed to use OpenAI models');\r\n            });\r\n            this.debug('Dynamically imported OpenAi');\r\n\r\n            if (model === SIMPLE_MODELS.OPENAI_GPT4_O) return new OpenAi({ modelName: 'gpt-4o' });\r\n            else if (model === SIMPLE_MODELS['OPENAI_GPT4_TURBO']) return new OpenAi({ modelName: 'gpt-4-turbo' });\r\n            else if (model === SIMPLE_MODELS['OPENAI_GPT3.5_TURBO']) return new OpenAi({ modelName: 'gpt-3.5-turbo' });\r\n            else throw new Error('Invalid model name');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The function `embedChunks` embeds the content of chunks by invoking the planned embedding model.\r\n     * @param {Pick<Chunk, 'pageContent'>[]} chunks - The `chunks` parameter is an array of objects\r\n     * that have a property `pageContent` which contains text content for each chunk.\r\n     * @returns The `embedChunks` function is returning the embedded vectors for the chunks.\r\n     */\r\n    private async embedChunks(chunks: Pick<Chunk, 'pageContent'>[]) {\r\n        const texts = chunks.map(({ pageContent }) => pageContent);\r\n        return this.embeddingModel.embedDocuments(texts);\r\n    }\r\n\r\n    /**\r\n     * The function `getChunkUniqueId` generates a unique identifier by combining a loader unique ID and\r\n     * an increment ID.\r\n     * @param {string} loaderUniqueId - A unique identifier for the loader.\r\n     * @param {number} incrementId - The `incrementId` parameter is a number that represents the\r\n     * increment value used to generate a unique chunk identifier.\r\n     * @returns The function `getChunkUniqueId` returns a string that combines the `loaderUniqueId` and\r\n     * `incrementId`.\r\n     */\r\n    private getChunkUniqueId(loaderUniqueId: string, incrementId: number) {\r\n        return `${loaderUniqueId}_${incrementId}`;\r\n    }\r\n\r\n    /**\r\n     * The function `addLoader` asynchronously initalizes a loader using the provided parameters and adds\r\n     * it to the system.\r\n     * @param {LoaderParam} loaderParam - The `loaderParam` parameter is a string, object or instance of BaseLoader\r\n     * that contains the necessary information to create a loader.\r\n     * @param {boolean} forceReload - The `forceReload` parameter is a boolean used to indicate if a loader should be reloaded.\r\n     * By default, loaders which have been previously run are not reloaded.\r\n     * @returns The function `addLoader` returns an object with the following properties:\r\n     * - `entriesAdded`: Number of new entries added during the loader operation\r\n     * - `uniqueId`: Unique identifier of the loader\r\n     * - `loaderType`: Name of the loader's constructor class\r\n     */\r\n    public async addLoader(loaderParam: BaseLoader, forceReload = false): Promise<AddLoaderReturn> {\r\n        return this._addLoader(loaderParam, forceReload);\r\n    }\r\n\r\n    /**\r\n     * The function `_addLoader` asynchronously adds a loader, processes its chunks, and handles\r\n     * incremental loading if supported by the loader.\r\n     * @param {BaseLoader} loader - The `loader` parameter in the `_addLoader` method is an instance of the\r\n     * `BaseLoader` class.\r\n     * @returns The function `_addLoader` returns an object with the following properties:\r\n     * - `entriesAdded`: Number of new entries added during the loader operation\r\n     * - `uniqueId`: Unique identifier of the loader\r\n     * - `loaderType`: Name of the loader's constructor class\r\n     */\r\n    private async _addLoader(loader: BaseLoader, forceReload: boolean): Promise<AddLoaderReturn> {\r\n        const uniqueId = loader.getUniqueId();\r\n        this.debug('Exploring loader', uniqueId);\r\n        if (this.model) loader.injectModel(this.model);\r\n\r\n        if (this.store && (await this.store.hasLoaderMetadata(uniqueId))) {\r\n            if (forceReload) {\r\n                const { chunksProcessed } = await this.store.getLoaderMetadata(uniqueId);\r\n\r\n                this.debug(\r\n                    `Loader previously run but forceReload set! Deleting previous ${chunksProcessed} keys...`,\r\n                    uniqueId,\r\n                );\r\n\r\n                this.loaders = this.loaders.filter((x) => x.getUniqueId() != loader.getUniqueId());\r\n                if (chunksProcessed > 0) await this.deleteLoader(uniqueId);\r\n            } else {\r\n                this.debug('Loader previously run. Skipping...', uniqueId);\r\n                return { entriesAdded: 0, uniqueId, loaderType: loader.constructor.name };\r\n            }\r\n        }\r\n\r\n        await loader.init();\r\n        const chunks = await loader.getChunks();\r\n\r\n        this.debug('Chunks generator received', uniqueId);\r\n        const { newInserts } = await this.batchLoadChunks(uniqueId, chunks);\r\n        this.debug(`Add loader completed with ${newInserts} new entries for`, uniqueId);\r\n\r\n        if (loader.canIncrementallyLoad) {\r\n            this.debug(`Registering incremental loader`, uniqueId);\r\n\r\n            loader.on('incrementalChunkAvailable', async (incrementalGenerator) => {\r\n                await this.incrementalLoader(uniqueId, incrementalGenerator);\r\n            });\r\n        }\r\n\r\n        this.loaders.push(loader);\r\n        this.debug(`Add loader ${uniqueId} wrap up done`);\r\n        return { entriesAdded: newInserts, uniqueId, loaderType: loader.constructor.name };\r\n    }\r\n\r\n    /**\r\n     * The `incrementalLoader` function asynchronously processes incremental chunks for a loader.\r\n     * @param {string} uniqueId - The `uniqueId` parameter is a string that serves as an identifier for\r\n     * the loader.\r\n     * @param incrementalGenerator - The `incrementalGenerator` parameter is an asynchronous generator\r\n     * function that yields `LoaderChunk` objects. It is used to incrementally load chunks of data for a specific loader\r\n     */\r\n    private async incrementalLoader(uniqueId: string, incrementalGenerator: AsyncGenerator<LoaderChunk, void, void>) {\r\n        this.debug(`incrementalChunkAvailable for loader`, uniqueId);\r\n        const { newInserts } = await this.batchLoadChunks(uniqueId, incrementalGenerator);\r\n        this.debug(`${newInserts} new incrementalChunks processed`, uniqueId);\r\n    }\r\n\r\n    /**\r\n     * The function `getLoaders` asynchronously retrieves a list of loaders loaded so far. This includes\r\n     * internal loaders that were loaded by other loaders. It requires that cache is enabled to work.\r\n     * @returns The list of loaders with some metadata about them.\r\n     */\r\n    public async getLoaders() {\r\n        if (!this.store) return [];\r\n        return this.store.getAllLoaderMetadata();\r\n    }\r\n\r\n    /**\r\n     * The function `batchLoadChunks` processes chunks of data in batches and formats them for insertion.\r\n     * @param {string} uniqueId - The `uniqueId` parameter is a string that represents a unique\r\n     * identifier for loader being processed.\r\n     * @param generator - The `incrementalGenerator` parameter in the `batchLoadChunks`\r\n     * function is an asynchronous generator that yields `LoaderChunk` objects.\r\n     * @returns The `batchLoadChunks` function returns an object with two properties:\r\n     * 1. `newInserts`: The total number of new inserts made during the batch loading process.\r\n     * 2. `formattedChunks`: An array containing the formatted chunks that were processed during the\r\n     * batch loading process.\r\n     */\r\n    private async batchLoadChunks(uniqueId: string, generator: AsyncGenerator<LoaderChunk, void, void>) {\r\n        let i = 0,\r\n            batchSize = 0,\r\n            newInserts = 0,\r\n            formattedChunks: Chunk[] = [];\r\n\r\n        for await (const chunk of generator) {\r\n            batchSize++;\r\n\r\n            const formattedChunk = {\r\n                pageContent: chunk.pageContent,\r\n                metadata: {\r\n                    ...chunk.metadata,\r\n                    uniqueLoaderId: uniqueId,\r\n                    id: this.getChunkUniqueId(uniqueId, i++),\r\n                },\r\n            };\r\n            formattedChunks.push(formattedChunk);\r\n\r\n            if (batchSize % DEFAULT_INSERT_BATCH_SIZE === 0) {\r\n                newInserts += await this.batchLoadEmbeddings(uniqueId, formattedChunks);\r\n                formattedChunks = [];\r\n                batchSize = 0;\r\n            }\r\n        }\r\n\r\n        newInserts += await this.batchLoadEmbeddings(uniqueId, formattedChunks);\r\n        return { newInserts, formattedChunks };\r\n    }\r\n\r\n    /**\r\n     * The function `batchLoadEmbeddings` asynchronously loads embeddings for formatted chunks and\r\n     * inserts them into a vector database.\r\n     * @param {string} loaderUniqueId - The `loaderUniqueId` parameter is a unique identifier for the\r\n     * loader that is used to load embeddings.\r\n     * @param {Chunk[]} formattedChunks - `formattedChunks` is an array of Chunk objects that contain\r\n     * page content, metadata, and other information needed for processing. The `batchLoadEmbeddings`\r\n     * function processes these chunks in batches to obtain embeddings for each chunk and then inserts\r\n     * them into a database for further use.\r\n     * @returns The function `batchLoadEmbeddings` returns the result of inserting the embed chunks\r\n     * into the vector database.\r\n     */\r\n    private async batchLoadEmbeddings(loaderUniqueId: string, formattedChunks: Chunk[]) {\r\n        if (formattedChunks.length === 0) return 0;\r\n\r\n        this.debug(`Processing batch (size ${formattedChunks.length}) for loader ${loaderUniqueId}`);\r\n        const embeddings = await this.embedChunks(formattedChunks);\r\n        this.debug(`Batch embeddings (size ${formattedChunks.length}) obtained for loader ${loaderUniqueId}`);\r\n\r\n        const embedChunks = formattedChunks.map((chunk, index) => {\r\n            return <InsertChunkData>{\r\n                pageContent: chunk.pageContent,\r\n                vector: embeddings[index],\r\n                metadata: chunk.metadata,\r\n            };\r\n        });\r\n\r\n        this.debug(`Inserting chunks for loader ${loaderUniqueId} to vectorDatabase`);\r\n        return this.vectorDatabase.insertChunks(embedChunks);\r\n    }\r\n\r\n    /**\r\n     * The function `getEmbeddingsCount` returns the count of embeddings stored in a vector database\r\n     * asynchronously.\r\n     * @returns The `getEmbeddingsCount` method is returning the number of embeddings stored in the\r\n     * vector database. It is an asynchronous function that returns a Promise with the count of\r\n     * embeddings as a number.\r\n     */\r\n    public async getEmbeddingsCount(): Promise<number> {\r\n        return this.vectorDatabase.getVectorCount();\r\n    }\r\n\r\n    /**\r\n     * The function `deleteConversation` deletes all entries related to a particular conversation from the database\r\n     * @param {string} conversationId - The `conversationId` that you want to delete. Pass 'default' to delete\r\n     * the default conversation thread that is created and maintained automatically\r\n     */\r\n    public async deleteConversation(conversationId: string) {\r\n        if (this.store) {\r\n            await this.store.deleteConversation(conversationId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The function `deleteLoader` deletes embeddings from a loader after confirming the action.\r\n     * @param {string} uniqueLoaderId - The `uniqueLoaderId` parameter is a string that represents the\r\n     * identifier of the loader that you want to delete.\r\n     * @returns The `deleteLoader` method returns a boolean value indicating the success of the operation.\r\n     */\r\n    public async deleteLoader(uniqueLoaderId: string) {\r\n        const deleteResult = await this.vectorDatabase.deleteKeys(uniqueLoaderId);\r\n        if (this.store && deleteResult) await this.store.deleteLoaderMetadataAndCustomValues(uniqueLoaderId);\r\n        this.loaders = this.loaders.filter((x) => x.getUniqueId() != uniqueLoaderId);\r\n        return deleteResult;\r\n    }\r\n\r\n    /**\r\n     * The function `reset` deletes all embeddings from the vector database if a\r\n     * confirmation is provided.\r\n     * @returns The `reset` function returns a boolean value indicating the result.\r\n     */\r\n    public async reset() {\r\n        await this.vectorDatabase.reset();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * The function `getEmbeddings` retrieves embeddings for a query, performs similarity search,\r\n     * filters and sorts the results based on relevance score, and returns a subset of the top results.\r\n     * @param {string} cleanQuery - The `cleanQuery` parameter is a string that represents the query\r\n     * input after it has been cleaned or processed to remove any unnecessary characters, symbols, or\r\n     * noise. This clean query is then used to generate embeddings for similarity search.\r\n     * @returns The `getEmbeddings` function returns a filtered and sorted array of search results based\r\n     * on the similarity score of the query embedded in the cleanQuery string. The results are filtered\r\n     * based on a relevance cutoff value, sorted in descending order of score, and then sliced to return\r\n     * only the number of results specified by the `searchResultCount` property.\r\n     */\r\n    public async getEmbeddings(cleanQuery: string, limitsPerDoc?: number) {\r\n        const queryEmbedded = await this.embeddingModel.embedQuery(cleanQuery);\r\n        const unfilteredResultSet = await this.vectorDatabase.similaritySearch(\r\n            queryEmbedded,\r\n            this.searchResultCount + 10,\r\n            limitsPerDoc,\r\n        );\r\n        this.debug(`Query resulted in ${unfilteredResultSet.length} chunks before filteration...`);\r\n\r\n        return unfilteredResultSet\r\n            .filter((result) => result.score > this.embeddingRelevanceCutOff)\r\n            .sort((a, b) => b.score - a.score)\r\n            .slice(0, this.searchResultCount);\r\n    }\r\n\r\n    /**\r\n     * The `search` function retrieves the unique embeddings for a given query without calling a LLM.\r\n     * @param {string} query - The `query` parameter is a string that represents the input query that\r\n     * needs to be processed.\r\n     * @returns An array of unique page content items / chunks.\r\n     */\r\n    public async search(query: string, limitsPerDoc?: number) {\r\n        const cleanQuery = cleanString(query);\r\n        const rawContext = await this.getEmbeddings(cleanQuery, limitsPerDoc);\r\n\r\n        return [...new Map(rawContext.map((item) => [item.pageContent, item])).values()];\r\n    }\r\n\r\n    /**\r\n     * This function takes a user query, retrieves relevant context, identifies unique sources, and\r\n     * returns the query result along with the list of sources.\r\n     * @param {string} userQuery - The `userQuery` parameter is a string that represents the query\r\n     * input provided by the user. It is used as input to retrieve context and ultimately generate a\r\n     * result based on the query.\r\n     * @param [options] - The `options` parameter in the `query` function is an optional object that\r\n     * can have the following properties:\r\n     * - conversationId - The `conversationId` parameter in the `query` method is an\r\n     * optional parameter that represents the unique identifier for a conversation. It allows you to\r\n     * track and associate the query with a specific conversation thread if needed. If provided, it can be\r\n     * used to maintain context or history related to the conversation.\r\n     * - customContext - You can pass in custom context from your own RAG stack. Passing.\r\n     * your own context will disable the inbuilt RAG retrieval for that specific query\r\n     * @returns The `query` method returns a Promise that resolves to an object with two properties:\r\n     * `result` and `sources`. The `result` property is a string representing the result of querying\r\n     * the LLM model with the provided query template, user query, context, and conversation history. The\r\n     * `sources` property is an array of strings representing unique sources used to generate the LLM response.\r\n     */\r\n    public async query(\r\n        userQuery: string,\r\n        options?: { conversationId?: string; customContext?: Chunk[]; limitConversation?: number; callback?: any },\r\n    ): Promise<QueryResponse> {\r\n        if (!this.model) {\r\n            throw new Error('LLM Not set; query method not available');\r\n        }\r\n\r\n        let context = options?.customContext;\r\n        if (!context) context = await this.search(userQuery);\r\n\r\n        let conversationId = options?.conversationId;\r\n        if (!conversationId && this.storeConversationsToDefaultThread) {\r\n            conversationId = 'default';\r\n        }\r\n\r\n        const sources = [...new Set(context.map((chunk) => chunk.metadata.source))];\r\n        this.debug(\r\n            `Query resulted in ${context.length} chunks after filteration; chunks from ${sources.length} unique sources.`,\r\n        );\r\n\r\n        return this.model.query(\r\n            this.systemMessage,\r\n            userQuery,\r\n            context,\r\n            conversationId,\r\n            options?.limitConversation,\r\n            options?.callback,\r\n        );\r\n    }\r\n}\r\n", "import {\r\n    BaseStore,\r\n    BaseVectorDatabase,\r\n    BaseEmbeddings,\r\n    BaseLoader,\r\n    BaseModel,\r\n    SIMPLE_MODELS,\r\n} from '@llm-tools/embedjs-interfaces';\r\nimport { MemoryStore } from '../store/memory-store.js';\r\nimport { RAGApplication } from './rag-application.js';\r\n\r\nexport class RAGApplicationBuilder {\r\n    private temperature: number;\r\n    private model: BaseModel | SIMPLE_MODELS | null;\r\n    private vectorDatabase: BaseVectorDatabase;\r\n    private loaders: BaseLoader[];\r\n    private store: BaseStore;\r\n    private systemMessage: string;\r\n    private searchResultCount: number;\r\n    private embeddingModel: BaseEmbeddings;\r\n    private embeddingRelevanceCutOff: number;\r\n    private storeConversationsToDefaultThread: boolean;\r\n\r\n    constructor() {\r\n        this.loaders = [];\r\n        this.temperature = 0.1;\r\n        this.searchResultCount = 30;\r\n        this.model = SIMPLE_MODELS.OPENAI_GPT4_TURBO;\r\n\r\n        this.systemMessage = `You are a helpful human like chat bot. Use relevant provided context and chat history to answer the query at the end. Answer in full.\r\n        If you don't know the answer, just say that you don't know, don't try to make up an answer.\r\n\r\n        Do not use words like context or training data when responding. You can say you do not have all the information but do not indicate that you are not a reliable source.`;\r\n\r\n        this.storeConversationsToDefaultThread = true;\r\n        this.embeddingRelevanceCutOff = 0;\r\n        this.store = new MemoryStore();\r\n    }\r\n\r\n    /**\r\n     * The `build` function creates a new `RAGApplication` entity and initializes it asynchronously based on provided parameters.\r\n     * @returns An instance of the `RAGApplication` class after it has been initialized asynchronously.\r\n     */\r\n    async build() {\r\n        const entity = new RAGApplication(this);\r\n        await entity.init(this);\r\n        return entity;\r\n    }\r\n\r\n    /**\r\n     * The function setVectorDatabase sets a BaseVectorDatabase object\r\n     * @param {BaseVectorDatabase} vectorDatabase - The `vectorDatabase` parameter is an instance of the `BaseVectorDatabase` class, which\r\n     * is used to store vectors in a database.\r\n     * @returns The `this` object is being returned, which allows for method chaining.\r\n     */\r\n    setVectorDatabase(vectorDatabase: BaseVectorDatabase) {\r\n        this.vectorDatabase = vectorDatabase;\r\n        return this;\r\n    }\r\n\r\n    setEmbeddingModel(embeddingModel: BaseEmbeddings) {\r\n        this.embeddingModel = embeddingModel;\r\n        return this;\r\n    }\r\n\r\n    setModel(model: 'NO_MODEL' | SIMPLE_MODELS | BaseModel) {\r\n        if (typeof model === 'object') this.model = model;\r\n        else {\r\n            if (model === 'NO_MODEL') this.model = null;\r\n            else this.model = model;\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    setStore(store: BaseStore) {\r\n        this.store = store;\r\n        return this;\r\n    }\r\n\r\n    setTemperature(temperature: number) {\r\n        this.temperature = temperature;\r\n        if (this.model) this.setModel(this.model);\r\n        return this;\r\n    }\r\n\r\n    setSystemMessage(systemMessage: string) {\r\n        this.systemMessage = systemMessage;\r\n        return this;\r\n    }\r\n\r\n    setEmbeddingRelevanceCutOff(embeddingRelevanceCutOff: number) {\r\n        this.embeddingRelevanceCutOff = embeddingRelevanceCutOff;\r\n        return this;\r\n    }\r\n\r\n    addLoader(loader: BaseLoader) {\r\n        this.loaders.push(loader);\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The setSearchResultCount function sets the search result count\r\n     * @param {number} searchResultCount - The `searchResultCount` parameter\r\n     * represents the count of search results picked up from the vector store per query.\r\n     * @returns The `this` object is being returned, which allows for method chaining.\r\n     */\r\n    setSearchResultCount(searchResultCount: number) {\r\n        this.searchResultCount = searchResultCount;\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * The setParamStoreConversationsToDefaultThread configures whether the conversation hisotry for queries made\r\n     * without a conversationId passed should be stored in the default thread. This is set to True by default.\r\n     */\r\n    setParamStoreConversationsToDefaultThread(storeConversationsToDefaultThread: boolean) {\r\n        this.storeConversationsToDefaultThread = storeConversationsToDefaultThread;\r\n        return this;\r\n    }\r\n\r\n    getLoaders() {\r\n        return this.loaders;\r\n    }\r\n\r\n    getSearchResultCount() {\r\n        return this.searchResultCount;\r\n    }\r\n\r\n    getVectorDatabase() {\r\n        return this.vectorDatabase;\r\n    }\r\n\r\n    getTemperature() {\r\n        return this.temperature;\r\n    }\r\n\r\n    getEmbeddingRelevanceCutOff() {\r\n        return this.embeddingRelevanceCutOff;\r\n    }\r\n\r\n    getSystemMessage() {\r\n        return this.systemMessage;\r\n    }\r\n\r\n    getStore() {\r\n        return this.store;\r\n    }\r\n\r\n    getEmbeddingModel() {\r\n        return this.embeddingModel;\r\n    }\r\n\r\n    getModel() {\r\n        return this.model;\r\n    }\r\n\r\n    getParamStoreConversationsToDefaultThread() {\r\n        return this.storeConversationsToDefaultThread;\r\n    }\r\n}\r\n", "import { BaseStore, Conversation, LoaderListEntry, Message } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class MemoryStore implements BaseStore {\r\n    private loaderCustomValues: Record<string, Record<string, unknown>>;\r\n    private loaderCustomValuesMap: Map<string, string[]>;\r\n    private loaderList: Record<string, LoaderListEntry>;\r\n    private conversations: Map<string, Conversation>;\r\n\r\n    async init(): Promise<void> {\r\n        this.loaderList = {};\r\n        this.loaderCustomValues = {};\r\n        this.conversations = new Map();\r\n        this.loaderCustomValuesMap = new Map();\r\n    }\r\n\r\n    async addLoaderMetadata(loaderId: string, value: LoaderListEntry): Promise<void> {\r\n        this.loaderList[loaderId] = value;\r\n    }\r\n\r\n    async getLoaderMetadata(loaderId: string): Promise<LoaderListEntry> {\r\n        return this.loaderList[loaderId];\r\n    }\r\n\r\n    async hasLoaderMetadata(loaderId: string): Promise<boolean> {\r\n        return !!this.loaderList[loaderId];\r\n    }\r\n\r\n    async getAllLoaderMetadata(): Promise<LoaderListEntry[]> {\r\n        return Object.values(this.loaderList);\r\n    }\r\n\r\n    async loaderCustomSet<T extends Record<string, unknown>>(loaderId: string, key: string, value: T): Promise<void> {\r\n        if (!this.loaderCustomValuesMap.has(loaderId)) this.loaderCustomValuesMap.set(loaderId, []);\r\n        this.loaderCustomValuesMap.get(loaderId).push(key);\r\n\r\n        this.loaderCustomValues[key] = { ...value, loaderId };\r\n    }\r\n\r\n    async loaderCustomGet<T extends Record<string, unknown>>(key: string): Promise<T> {\r\n        const data = <T & { loaderId: string }>this.loaderCustomValues[key];\r\n        delete data.loaderId;\r\n        return data;\r\n    }\r\n\r\n    async loaderCustomHas(key: string): Promise<boolean> {\r\n        return !!this.loaderCustomValues[key];\r\n    }\r\n\r\n    async loaderCustomDelete(key: string): Promise<void> {\r\n        const loaderId = <string>this.loaderCustomValues[key].loaderId;\r\n\r\n        delete this.loaderList[key];\r\n\r\n        if (this.loaderCustomValuesMap.has(loaderId)) {\r\n            this.loaderCustomValuesMap.set(\r\n                loaderId,\r\n                this.loaderCustomValuesMap.get(loaderId).filter((k) => k !== key),\r\n            );\r\n        }\r\n    }\r\n\r\n    async deleteLoaderMetadataAndCustomValues(loaderId: string): Promise<void> {\r\n        if (this.loaderCustomValuesMap.has(loaderId)) {\r\n            this.loaderCustomValuesMap.get(loaderId).forEach((key) => {\r\n                delete this.loaderCustomValues[key];\r\n            });\r\n        }\r\n\r\n        this.loaderCustomValuesMap.delete(loaderId);\r\n        delete this.loaderList[loaderId];\r\n    }\r\n\r\n    async addConversation(conversationId: string): Promise<void> {\r\n        if (!this.conversations.has(conversationId)) {\r\n            this.conversations.set(conversationId, { conversationId, entries: [] });\r\n        }\r\n    }\r\n\r\n    async getConversation(conversationId: string): Promise<Conversation> {\r\n        return this.conversations.get(conversationId);\r\n    }\r\n\r\n    async hasConversation(conversationId: string): Promise<boolean> {\r\n        return this.conversations.has(conversationId);\r\n    }\r\n\r\n    async deleteConversation(conversationId: string): Promise<void> {\r\n        this.conversations.delete(conversationId);\r\n    }\r\n\r\n    async addEntryToConversation(conversationId: string, entry: Message): Promise<void> {\r\n        const conversation = await this.getConversation(conversationId);\r\n        conversation.entries.push(entry);\r\n    }\r\n\r\n    async clearConversations(): Promise<void> {\r\n        this.conversations.clear();\r\n    }\r\n}\r\n", "import { getMimeType } from 'stream-mime-type';\r\nimport createDebugMessages from 'debug';\r\nimport path from 'node:path';\r\nimport fs from 'node:fs';\r\nimport md5 from 'md5';\r\n\r\nimport { createLoaderFromMimeType } from '../util/mime.js';\r\nimport { BaseLoader, UnfilteredLoaderChunk } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class LocalPathLoader extends BaseLoader<{ type: 'LocalPathLoader' }> {\r\n    private readonly debug = createDebugMessages('embedjs:loader:LocalPathLoader');\r\n    private readonly path: string;\r\n\r\n    constructor({ path }: { path: string }) {\r\n        super(`LocalPathLoader_${md5(path)}`, { path });\r\n        this.path = path;\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        for await (const result of await this.recursivelyAddPath(this.path)) {\r\n            yield {\r\n                ...result,\r\n                metadata: {\r\n                    ...result.metadata,\r\n                    type: <const>'LocalPathLoader',\r\n                    originalPath: this.path,\r\n                },\r\n            };\r\n        }\r\n    }\r\n\r\n    private async *recursivelyAddPath(currentPath: string): AsyncGenerator<UnfilteredLoaderChunk, void, void> {\r\n        const isDir = fs.lstatSync(currentPath).isDirectory();\r\n        this.debug(`Processing path '${currentPath}'. It is a ${isDir ? 'Directory!' : 'file...'}`);\r\n\r\n        if (!isDir) {\r\n            const stream = fs.createReadStream(currentPath);\r\n            let { mime } = await getMimeType(stream);\r\n            stream.destroy();\r\n\r\n            this.debug(`File '${this.path}' has mime type '${mime}'`);\r\n            if (mime === 'application/octet-stream') {\r\n                const extension = currentPath.split('.').pop().toLowerCase();\r\n                if (extension === 'md' || extension === 'mdx') mime = 'text/markdown';\r\n                this.debug(`File '${this.path}' mime type updated to 'text/markdown'`);\r\n            }\r\n\r\n            try {\r\n                const loader = await createLoaderFromMimeType(currentPath, mime);\r\n                for await (const result of await loader.getUnfilteredChunks()) {\r\n                    yield {\r\n                        pageContent: result.pageContent,\r\n                        metadata: {\r\n                            source: currentPath,\r\n                        },\r\n                    };\r\n                }\r\n            } catch (err) {\r\n                this.debug(`Error creating loader for mime type '${mime}'`, err);\r\n            }\r\n        } else {\r\n            const files = fs.readdirSync(currentPath);\r\n            this.debug(`Dir '${currentPath}' has ${files.length} entries inside`, files);\r\n\r\n            for (const file of files) {\r\n                for await (const result of await this.recursivelyAddPath(path.resolve(currentPath, file))) {\r\n                    yield result;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "import mime from 'mime';\r\nimport createDebugMessages from 'debug';\r\n\r\nimport { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { TextLoader } from '../loaders/text-loader.js';\r\n\r\nexport async function createLoaderFromMimeType(loaderData: string, mimeType: string): Promise<BaseLoader> {\r\n    createDebugMessages('embedjs:util:createLoaderFromMimeType')(`Incoming mime type '${mimeType}'`);\r\n\r\n    switch (mimeType) {\r\n        case 'application/msword':\r\n        case 'application/vnd.openxmlformats-officedocument.wordprocessingml.document': {\r\n            const { DocxLoader } = await import('@llm-tools/embedjs-loader-msoffice').catch(() => {\r\n                throw new Error(\r\n                    'Package `@llm-tools/embedjs-loader-msoffice` needs to be installed to load docx files',\r\n                );\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported DocxLoader');\r\n            return new DocxLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'application/vnd.ms-excel':\r\n        case 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': {\r\n            const { ExcelLoader } = await import('@llm-tools/embedjs-loader-msoffice').catch(() => {\r\n                throw new Error(\r\n                    'Package `@llm-tools/embedjs-loader-msoffice` needs to be installed to load excel files',\r\n                );\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported ExcelLoader');\r\n            return new ExcelLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'application/pdf': {\r\n            const { PdfLoader } = await import('@llm-tools/embedjs-loader-pdf').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-pdf` needs to be installed to load PDF files');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported PdfLoader');\r\n            return new PdfLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'application/vnd.openxmlformats-officedocument.presentationml.presentation': {\r\n            const { PptLoader } = await import('@llm-tools/embedjs-loader-msoffice').catch(() => {\r\n                throw new Error(\r\n                    'Package `@llm-tools/embedjs-loader-msoffice` needs to be installed to load pptx files',\r\n                );\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported PptLoader');\r\n            return new PptLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'text/plain': {\r\n            const fineType = mime.getType(loaderData);\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')(\r\n                `Fine type for '${loaderData}' is '${fineType}'`,\r\n            );\r\n            if (fineType === 'text/csv') {\r\n                const { CsvLoader } = await import('@llm-tools/embedjs-loader-csv').catch(() => {\r\n                    throw new Error('Package `@llm-tools/embedjs-loader-csv` needs to be installed to load CSV files');\r\n                });\r\n\r\n                createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported CsvLoader');\r\n                return new CsvLoader({ filePathOrUrl: loaderData });\r\n            } else return new TextLoader({ text: loaderData });\r\n        }\r\n        case 'application/csv': {\r\n            const { CsvLoader } = await import('@llm-tools/embedjs-loader-csv').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-csv` needs to be installed to load CSV files');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported CsvLoader');\r\n            return new CsvLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'text/html': {\r\n            const { WebLoader } = await import('@llm-tools/embedjs-loader-web').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-web` needs to be installed to load web documents');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported WebLoader');\r\n            return new WebLoader({ urlOrContent: loaderData });\r\n        }\r\n        case 'text/xml': {\r\n            const { SitemapLoader } = await import('@llm-tools/embedjs-loader-sitemap').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-sitemap` needs to be installed to load sitemaps');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported SitemapLoader');\r\n\r\n            if (await SitemapLoader.test(loaderData)) {\r\n                return new SitemapLoader({ url: loaderData });\r\n            }\r\n\r\n            //This is not a Sitemap but is still XML\r\n            const { XmlLoader } = await import('@llm-tools/embedjs-loader-xml').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-xml` needs to be installed to load XML documents');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported XmlLoader');\r\n            return new XmlLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'text/x-markdown':\r\n        case 'text/markdown': {\r\n            const { MarkdownLoader } = await import('@llm-tools/embedjs-loader-markdown').catch(() => {\r\n                throw new Error(\r\n                    'Package `@llm-tools/embedjs-loader-markdown` needs to be installed to load markdown files',\r\n                );\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported MarkdownLoader');\r\n            return new MarkdownLoader({ filePathOrUrl: loaderData });\r\n        }\r\n        case 'image/png':\r\n        case 'image/jpeg': {\r\n            const { ImageLoader } = await import('@llm-tools/embedjs-loader-image').catch(() => {\r\n                throw new Error('Package `@llm-tools/embedjs-loader-image` needs to be installed to load images');\r\n            });\r\n            createDebugMessages('embedjs:util:createLoaderFromMimeType')('Dynamically imported ImageLoader');\r\n            return new ImageLoader({ filePathOrUrl: loaderData, mime: mimeType });\r\n        }\r\n\r\n        case undefined:\r\n            throw new Error(`MIME type could not be detected. Please file an issue if you think this is a bug.`);\r\n        default:\r\n            throw new Error(`Unknown mime type '${mimeType}'`);\r\n    }\r\n}\r\n", "import { RecursiveCharacterTextSplitter } from '@langchain/textsplitters';\r\nimport md5 from 'md5';\r\n\r\nimport { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { truncateCenterString, cleanString } from '@llm-tools/embedjs-utils';\r\n\r\nexport function returnTagID(fullStr: string, strLen: number) {\r\n    let parts = fullStr.split(' ');\r\n    if (parts.length > 1) {\r\n        return parts[0];\r\n    } else {\r\n        if (fullStr.length <= strLen) return fullStr;\r\n        //SVOBODA\r\n        return fullStr.substring(0, strLen);\r\n    }\r\n}\r\n\r\nexport class TextLoader extends BaseLoader<{ type: 'TextLoader' }> {\r\n    private readonly text: string;\r\n\r\n    constructor({\r\n        text,\r\n        chunkSize,\r\n        chunkOverlap,\r\n        middleId,\r\n    }: {\r\n        text: string;\r\n        chunkSize?: number;\r\n        chunkOverlap?: number;\r\n        middleId?: string;\r\n    }) {\r\n        if (middleId) {\r\n            let id = `TextLoader_${middleId}_${md5(text)}`;\r\n            super(id, { text: returnTagID(text, 50) }, chunkSize ?? 300, chunkOverlap ?? 0);\r\n        } else {\r\n            let id = `TextLoader_${md5(text)}`;\r\n            super(id, { text: truncateCenterString(text, 50) }, chunkSize ?? 300, chunkOverlap ?? 0);\r\n        }\r\n\r\n        this.text = text;\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        let tuncatedObjectString;\r\n        if (this.uniqueId.split('_').length > 1) {\r\n            tuncatedObjectString = returnTagID(this.text, 50);\r\n        } else {\r\n            tuncatedObjectString = truncateCenterString(this.text, 50);\r\n        }\r\n\r\n        const chunker = new RecursiveCharacterTextSplitter({\r\n            chunkSize: this.chunkSize,\r\n            chunkOverlap: this.chunkOverlap,\r\n        });\r\n        const chunks = await chunker.splitText(cleanString(this.text));\r\n\r\n        for (const chunk of chunks) {\r\n            yield {\r\n                pageContent: chunk,\r\n                metadata: {\r\n                    type: 'TextLoader' as const,\r\n                    source: tuncatedObjectString,\r\n                    textId: this.uniqueId,\r\n                },\r\n            };\r\n        }\r\n    }\r\n}\r\n", "import { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { cleanString, truncateCenterString } from '@llm-tools/embedjs-utils';\r\nimport md5 from 'md5';\r\n\r\nexport class JsonLoader extends BaseLoader<{ type: 'JsonLoader' }> {\r\n    private readonly object: Record<string, unknown> | Record<string, unknown>[];\r\n    private readonly pickKeysForEmbedding?: string[];\r\n\r\n    constructor({\r\n        object,\r\n        pickKeysForEmbedding,\r\n    }: {\r\n        object: Record<string, unknown> | Record<string, unknown>[];\r\n        pickKeysForEmbedding?: string[];\r\n    }) {\r\n        super(`JsonLoader_${md5(cleanString(JSON.stringify(object)))}`, {\r\n            object: truncateCenterString(JSON.stringify(object), 50),\r\n        });\r\n\r\n        this.pickKeysForEmbedding = pickKeysForEmbedding;\r\n        this.object = object;\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        const tuncatedObjectString = truncateCenterString(JSON.stringify(this.object), 50);\r\n        const array = Array.isArray(this.object) ? this.object : [this.object];\r\n\r\n        for (const entry of array) {\r\n            let s: string;\r\n            if (this.pickKeysForEmbedding) {\r\n                const subset = Object.fromEntries(\r\n                    this.pickKeysForEmbedding\r\n                        .filter((key) => key in entry) // line can be removed to make it inclusive\r\n                        .map((key) => [key, entry[key]]),\r\n                );\r\n                s = cleanString(JSON.stringify(subset));\r\n            } else {\r\n                s = cleanString(JSON.stringify(entry));\r\n            }\r\n\r\n            if ('id' in entry) {\r\n                entry.preEmbedId = entry.id;\r\n                delete entry.id;\r\n            }\r\n\r\n            yield {\r\n                pageContent: s,\r\n                metadata: {\r\n                    type: 'JsonLoader' as const,\r\n                    source: tuncatedObjectString,\r\n                },\r\n            };\r\n        }\r\n    }\r\n}\r\n", "import { getMimeType } from 'stream-mime-type';\r\nimport createDebugMessages from 'debug';\r\nimport md5 from 'md5';\r\n\r\nimport { contentTypeToMimeType, getSafe, truncateCenterString } from '@llm-tools/embedjs-utils';\r\nimport { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { createLoaderFromMimeType } from '../util/mime.js';\r\n\r\nexport class UrlLoader extends BaseLoader<{ type: 'UrlLoader' }> {\r\n    private readonly debug = createDebugMessages('embedjs:loader:UrlLoader');\r\n    private readonly url: URL;\r\n\r\n    constructor({ url }: { url: string }) {\r\n        super(`UrlLoader_${md5(url)}`, { url: truncateCenterString(url, 50) });\r\n        this.url = new URL(url);\r\n        this.debug(`UrlLoader verified '${url}' is a valid URL!`);\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        const response = await getSafe(this.url.href, { headers: { 'Accept-Encoding': '' } });\r\n        const stream = response.body as unknown as NodeJS.ReadableStream;\r\n        let { mime } = await getMimeType(stream, { strict: true });\r\n        this.debug(`Loader stream detected type '${mime}'`);\r\n\r\n        if (!mime) {\r\n            mime = contentTypeToMimeType(response.headers.get('content-type'));\r\n            this.debug(`Using type '${mime}' from content-type header`);\r\n        }\r\n\r\n        try {\r\n            const loader = await createLoaderFromMimeType(this.url.href, mime);\r\n            for await (const result of await loader.getUnfilteredChunks()) {\r\n                yield {\r\n                    pageContent: result.pageContent,\r\n                    metadata: {\r\n                        type: <const>'UrlLoader',\r\n                        source: this.url.href,\r\n                    },\r\n                };\r\n            }\r\n        } catch (err) {\r\n            this.debug(`Error creating loader for mime type '${mime}'`, err);\r\n        }\r\n    }\r\n}\r\n", "import { RAGApplication } from './core/rag-application.js';\r\nimport { RAGApplicationBuilder } from './core/rag-application-builder.js';\r\nimport { LocalPathLoader } from './loaders/local-path-loader.js';\r\nimport { TextLoader } from './loaders/text-loader.js';\r\nimport { JsonLoader } from './loaders/json-loader.js';\r\nimport { UrlLoader } from './loaders/url-loader.js';\r\nimport { SIMPLE_MODELS } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport { RAGApplication, RAGApplicationBuilder, TextLoader, JsonLoader, LocalPathLoader, UrlLoader, SIMPLE_MODELS };\r\n", "import createDebugMessages from 'debug';\r\nimport { Client, createClient } from '@libsql/client';\r\n\r\nimport { BaseVectorDatabase, ExtractChunkData, InsertChunkData } from '@llm-tools/embedjs-interfaces';\r\nimport { truncateCenterString } from '@llm-tools/embedjs-utils';\r\n\r\nexport class LibSqlDb implements BaseVectorDatabase {\r\n    private readonly debug = createDebugMessages('embedjs:vector:LibSqlDb');\r\n    private readonly tableName: string;\r\n    private readonly client: Client;\r\n\r\n    constructor({ path, tableName }: { path: string; tableName?: string }) {\r\n        this.tableName = tableName ?? 'vectors';\r\n        this.client = createClient({\r\n            url: `file:${path}`,\r\n        });\r\n    }\r\n\r\n    async init({ dimensions }: { dimensions: number }) {\r\n        await this.client.execute(`CREATE TABLE IF NOT EXISTS ${this.tableName} (\r\n            id              TEXT PRIMARY KEY,\r\n            pageContent     TEXT UNIQUE,\r\n            uniqueLoaderId  TEXT NOT NULL,\r\n            source          TEXT NOT NULL,\r\n            vector          F32_BLOB(${dimensions}),\r\n            metadata        TEXT\r\n        );`);\r\n    }\r\n\r\n    async insertChunks(chunks: InsertChunkData[]): Promise<number> {\r\n        const batch = chunks.map((chunk) => {\r\n            return {\r\n                sql: `INSERT OR IGNORE INTO ${this.tableName} (id, pageContent, uniqueLoaderId, source, vector, metadata)\r\n            VALUES (?, ?, ?, ?, vector32('[${chunk.vector.join(',')}]'), ?);`,\r\n                args: [\r\n                    chunk.metadata.id,\r\n                    chunk.pageContent,\r\n                    chunk.metadata.uniqueLoaderId,\r\n                    chunk.metadata.source,\r\n                    JSON.stringify(chunk.metadata),\r\n                ],\r\n            };\r\n        });\r\n\r\n        this.debug(`Executing batch - ${truncateCenterString(JSON.stringify(batch), 1000)}`);\r\n        const result = await this.client.batch(batch, 'write');\r\n        return result.reduce((a, b) => a + b.rowsAffected, 0);\r\n    }\r\n\r\n    async similaritySearch(query: number[], k: number, docLimit?: number): Promise<ExtractChunkData[]> {\r\n        let statement = `SELECT id, pageContent, uniqueLoaderId, source, metadata,\r\n                vector_distance_cos(vector, vector32('[${query.join(',')}]')) as distance\r\n            FROM ${this.tableName}\r\n            ORDER BY vector_distance_cos(vector, vector32('[${query.join(',')}]')) ASC\r\n            LIMIT ${k};`;\r\n\r\n        if (docLimit) {\r\n            statement = `\r\n    WITH ranked_results AS (\r\n        SELECT id, pageContent, uniqueLoaderId, source, metadata,\r\n               vector_distance_cos(vector, vector32('[${query.join(',')}]')) as distance,\r\n               (SELECT COUNT(*) \r\n                FROM ${this.tableName} AS sub \r\n                WHERE sub.uniqueLoaderId = main.uniqueLoaderId \r\n                AND sub.id <= main.id) AS row_num\r\n        FROM ${this.tableName} AS main\r\n        ORDER BY distance ASC\r\n    )\r\n    SELECT id, pageContent, uniqueLoaderId, source, metadata, distance\r\n    FROM ranked_results\r\n    WHERE row_num <= ${docLimit}\r\n    ORDER BY distance ASC\r\n    LIMIT ${k};\r\n`;\r\n        }\r\n\r\n        this.debug(`Executing statement - ${truncateCenterString(statement, 700)}`);\r\n        const results = await this.client.execute(statement);\r\n\r\n        return results.rows.map((result) => {\r\n            const metadata = JSON.parse(result.metadata.toString());\r\n\r\n            return {\r\n                metadata,\r\n                pageContent: result.pageContent.toString(),\r\n                score: 1 - <number>result.distance,\r\n            };\r\n        });\r\n    }\r\n\r\n    async getVectorCount(): Promise<number> {\r\n        const statement = `SELECT count(id) as count FROM ${this.tableName};`;\r\n\r\n        this.debug(`Executing statement - ${statement}`);\r\n        const results = await this.client.execute(statement);\r\n\r\n        return Number.parseInt(results.rows[0].count.toString());\r\n    }\r\n\r\n    async deleteKeys(uniqueLoaderId: string): Promise<boolean> {\r\n        await this.client.execute(`DELETE FROM ${this.tableName} WHERE\r\n           uniqueLoaderId = '${uniqueLoaderId}';`);\r\n        return true;\r\n    }\r\n\r\n    async reset(): Promise<void> {\r\n        await this.client.execute(`DELETE FROM ${this.tableName};`);\r\n    }\r\n}\r\n", "import createDebugMessages from 'debug';\r\nimport { Client, createClient } from '@libsql/client';\r\nimport { BaseStore, Conversation, LoaderListEntry, Message } from '@llm-tools/embedjs-interfaces';\r\n\r\nexport class LibSqlStore implements BaseStore {\r\n    private readonly debug = createDebugMessages('embedjs:store:LibSqlStore');\r\n    private readonly loadersCustomDataTableName: string;\r\n    private readonly conversationsTableName: string;\r\n    private readonly loadersTableName: string;\r\n    private readonly client: Client;\r\n\r\n    constructor({\r\n        path,\r\n        loadersTableName,\r\n        conversationsTableName,\r\n        loadersCustomDataTableName,\r\n    }: {\r\n        path: string;\r\n        loadersTableName?: string;\r\n        conversationsTableName?: string;\r\n        loadersCustomDataTableName?: string;\r\n    }) {\r\n        this.loadersCustomDataTableName = loadersCustomDataTableName ?? 'loaderCustomData';\r\n        this.conversationsTableName = conversationsTableName ?? 'conversations';\r\n        this.loadersTableName = loadersTableName ?? 'loaders';\r\n        this.client = createClient({\r\n            url: `file:${path}`,\r\n        });\r\n    }\r\n\r\n    async init(): Promise<void> {\r\n        this.debug(`Creating table '${this.conversationsTableName}'`);\r\n        await this.client.execute(`CREATE TABLE IF NOT EXISTS ${this.conversationsTableName} (\r\n            id              TEXT PRIMARY KEY,\r\n            conversationId  TEXT NOT NULL,\r\n            content         TEXT NOT NULL,\r\n            timestamp       TEXT NOT NULL,\r\n            actor           TEXT NOT NULL,\r\n            sources         TEXT\r\n        );\r\n\r\n        CREATE INDEX ${this.conversationsTableName}_index ON ${this.conversationsTableName} (conversationId);`);\r\n        this.debug(`Created table '${this.conversationsTableName}' and related indexes`);\r\n\r\n        this.debug(`Creating table '${this.loadersTableName}'`);\r\n        await this.client.execute(`CREATE TABLE IF NOT EXISTS ${this.loadersTableName} (\r\n            id              TEXT PRIMARY KEY,\r\n            type            TEXT NOT NULL,\r\n            chunksProcessed INTEGER,\r\n            metadata        TEXT\r\n        );`);\r\n        this.debug(`Created table '${this.loadersTableName}'`);\r\n\r\n        this.debug(`Creating table '${this.loadersCustomDataTableName}'`);\r\n        await this.client.execute(`CREATE TABLE IF NOT EXISTS ${this.loadersCustomDataTableName} (\r\n            key             TEXT PRIMARY KEY,\r\n            loaderId        TEXT NOT NULL,\r\n            value           TEXT\r\n        );\r\n\r\n        CREATE INDEX ${this.loadersCustomDataTableName}_index ON ${this.loadersCustomDataTableName} (loaderId);`);\r\n        this.debug(`Created table '${this.loadersCustomDataTableName}' and related indexes`);\r\n    }\r\n\r\n    async addLoaderMetadata(loaderId: string, value: LoaderListEntry): Promise<void> {\r\n        await this.client.execute(`DELETE FROM ${this.loadersTableName} WHERE id = '${loaderId}';`);\r\n\r\n        await this.client.execute({\r\n            sql: `INSERT INTO ${this.loadersTableName} (id, type, chunksProcessed, metadata)\r\n                VALUES (?, ?, ?, ?)`,\r\n            args: [loaderId, value.type, value.chunksProcessed, JSON.stringify(value.loaderMetadata)],\r\n        });\r\n    }\r\n\r\n    async getLoaderMetadata(loaderId: string): Promise<LoaderListEntry> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT type, chunksProcessed, metadata FROM ${this.loadersTableName} WHERE id = ?;`,\r\n            args: [loaderId],\r\n        });\r\n\r\n        const result = results.rows[0];\r\n        const metadata = JSON.parse(result.metadata.toString());\r\n\r\n        return {\r\n            uniqueId: loaderId,\r\n            loaderMetadata: metadata,\r\n            chunksProcessed: Number.parseInt(result.chunksProcessed.toString()),\r\n            type: result.type.toString(),\r\n        };\r\n    }\r\n\r\n    async hasLoaderMetadata(loaderId: string): Promise<boolean> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT type, chunksProcessed, metadata FROM ${this.loadersTableName} WHERE id = ?;`,\r\n            args: [loaderId],\r\n        });\r\n\r\n        return results.rows.length > 0;\r\n    }\r\n\r\n    async getAllLoaderMetadata(): Promise<LoaderListEntry[]> {\r\n        const results = await this.client.execute(\r\n            `SELECT id, type, chunksProcessed, metadata FROM ${this.loadersTableName};`,\r\n        );\r\n\r\n        return results.rows.map((result) => {\r\n            const metadata = JSON.parse(result.metadata.toString());\r\n\r\n            return {\r\n                uniqueId: result.id.toString(),\r\n                loaderMetadata: metadata,\r\n                chunksProcessed: Number.parseInt(result.chunksProcessed.toString()),\r\n                type: result.type.toString(),\r\n            };\r\n        });\r\n    }\r\n\r\n    async loaderCustomSet<T extends Record<string, unknown>>(loaderId: string, key: string, value: T): Promise<void> {\r\n        this.debug(`LibSQL custom set '${key}' with values`, value);\r\n        await this.loaderCustomDelete(key);\r\n\r\n        this.debug(`LibSQL custom set '${key}' insert started`);\r\n        const results = await this.client.execute({\r\n            sql: `INSERT INTO ${this.loadersCustomDataTableName} (key, loaderId, value)\r\n                VALUES (?, ?, ?)`,\r\n            args: [key, loaderId, JSON.stringify(value)],\r\n        });\r\n\r\n        this.debug(`LibSQL custom set for key '${key}' resulted in`, results.rows);\r\n    }\r\n\r\n    async loaderCustomGet<T extends Record<string, unknown>>(key: string): Promise<T> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT value FROM ${this.loadersCustomDataTableName} WHERE key = ?;`,\r\n            args: [key],\r\n        });\r\n\r\n        return JSON.parse(results.rows[0].value.toString());\r\n    }\r\n\r\n    async loaderCustomHas(key: string): Promise<boolean> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT value FROM ${this.loadersCustomDataTableName} WHERE key = ?;`,\r\n            args: [key],\r\n        });\r\n\r\n        return results.rows.length > 0;\r\n    }\r\n\r\n    async loaderCustomDelete(key: string): Promise<void> {\r\n        this.debug(`LibSQL custom delete '${key}'`);\r\n        const results = await this.client.execute(\r\n            `DELETE FROM ${this.loadersCustomDataTableName} WHERE key = '${key}';`,\r\n        );\r\n        this.debug(`LibSQL custom delete for key '${key}' resulted in`, results.rowsAffected);\r\n    }\r\n\r\n    async deleteLoaderMetadataAndCustomValues(loaderId: string): Promise<void> {\r\n        this.debug(`LibSQL deleteLoaderMetadataAndCustomValues for loader '${loaderId}'`);\r\n        await this.client.execute(`DELETE FROM ${this.loadersTableName} WHERE id = '${loaderId}';`);\r\n        await this.client.execute(`DELETE FROM ${this.loadersCustomDataTableName} WHERE loaderId = '${loaderId}';`);\r\n    }\r\n\r\n    async getConversation(conversationId: string): Promise<Conversation> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT id, conversationId, content, timestamp, actor, sources FROM ${this.conversationsTableName} WHERE conversationId = ?;`,\r\n            args: [conversationId],\r\n        });\r\n\r\n        return {\r\n            conversationId,\r\n            entries: results.rows.map((result) => {\r\n                const timestamp = new Date(result.timestamp.toString());\r\n                const actor = result.actor.toString();\r\n\r\n                if (actor === 'AI') {\r\n                    return {\r\n                        actor: 'AI',\r\n                        id: result.id.toString(),\r\n                        content: result.content.toString(),\r\n                        sources: JSON.parse(result.sources.toString()),\r\n                        timestamp,\r\n                    };\r\n                } else {\r\n                    return {\r\n                        id: result.id.toString(),\r\n                        content: result.content.toString(),\r\n                        actor: <'HUMAN' | 'SYSTEM'>actor,\r\n                        timestamp,\r\n                    };\r\n                }\r\n            }),\r\n        };\r\n    }\r\n\r\n    async hasConversation(conversationId: string): Promise<boolean> {\r\n        const results = await this.client.execute({\r\n            sql: `SELECT id, conversationId, content, timestamp, actor FROM ${this.conversationsTableName} WHERE conversationId = ? LIMIT 1;`,\r\n            args: [conversationId],\r\n        });\r\n\r\n        return results.rows.length > 0;\r\n    }\r\n\r\n    async deleteConversation(conversationId: string): Promise<void> {\r\n        await this.client.execute(\r\n            `DELETE FROM ${this.conversationsTableName} WHERE conversationId = '${conversationId}';`,\r\n        );\r\n    }\r\n\r\n    async addEntryToConversation(conversationId: string, entry: Message): Promise<void> {\r\n        if (entry.actor !== 'AI') {\r\n            await this.client.execute({\r\n                sql: `INSERT OR IGNORE INTO ${this.conversationsTableName} (id, conversationId, content, timestamp, actor)\r\n                VALUES (?, ?, ?, ?, ?)`,\r\n                args: [entry.id, conversationId, entry.content, entry.timestamp, entry.actor],\r\n            });\r\n        } else {\r\n            await this.client.execute({\r\n                sql: `INSERT OR IGNORE INTO ${this.conversationsTableName} (id, conversationId, content, timestamp, actor, sources)\r\n                VALUES (?, ?, ?, ?, ?, ?)`,\r\n                args: [\r\n                    entry.id,\r\n                    conversationId,\r\n                    entry.content,\r\n                    entry.timestamp,\r\n                    entry.actor,\r\n                    JSON.stringify(entry.sources),\r\n                ],\r\n            });\r\n        }\r\n    }\r\n\r\n    async clearConversations(): Promise<void> {\r\n        await this.client.execute(`DELETE FROM ${this.conversationsTableName};`);\r\n    }\r\n\r\n    async addConversation(_conversationId: string): Promise<void> {\r\n        //There is nothing to be done for this in this libsql implementation\r\n    }\r\n}\r\n", "import { ConfluenceClient } from 'confluence.js';\r\nimport createDebugMessages from 'debug';\r\nimport md5 from 'md5';\r\n\r\nimport { BaseLoader } from '@llm-tools/embedjs-interfaces';\r\nimport { WebLoader } from '@llm-tools/embedjs-loader-web';\r\n\r\nexport class ConfluenceLoader extends BaseLoader<{ type: 'ConfluenceLoader' }, { version: number }> {\r\n    private readonly debug = createDebugMessages('embedjs:loader:ConfluenceLoader');\r\n\r\n    private readonly confluence: ConfluenceClient;\r\n    private readonly confluenceBaseUrl: string;\r\n    private readonly spaceName: string;\r\n\r\n    private readonly lastUpdatedFilter?: Date;\r\n\r\n    constructor({\r\n        spaceName,\r\n        confluenceBaseUrl,\r\n        confluenceUsername,\r\n        confluenceToken,\r\n        chunkSize,\r\n        chunkOverlap,\r\n        filterOptions,\r\n    }: {\r\n        spaceName: string;\r\n        confluenceBaseUrl?: string;\r\n        confluenceUsername?: string;\r\n        confluenceToken?: string;\r\n        chunkSize?: number;\r\n        chunkOverlap?: number;\r\n        filterOptions?: {\r\n            lastUpdatedFilter: Date;\r\n        };\r\n    }) {\r\n        super(`ConfluenceLoader_${md5(spaceName)}`, { spaceName }, chunkSize ?? 2000, chunkOverlap ?? 200);\r\n\r\n        this.spaceName = spaceName;\r\n        this.confluenceBaseUrl = confluenceBaseUrl ?? process.env.CONFLUENCE_BASE_URL;\r\n        this.lastUpdatedFilter = filterOptions?.lastUpdatedFilter ?? null;\r\n\r\n        this.confluence = new ConfluenceClient({\r\n            host: this.confluenceBaseUrl,\r\n            authentication: {\r\n                basic: {\r\n                    username: confluenceUsername ?? process.env.CONFLUENCE_USER_NAME,\r\n                    password: confluenceToken ?? process.env.CONFLUENCE_API_TOKEN,\r\n                },\r\n            },\r\n        });\r\n    }\r\n\r\n    override async *getUnfilteredChunks() {\r\n        let count = 0;\r\n        for await (const result of this.processSpace(this.spaceName)) {\r\n            yield result;\r\n            count++;\r\n        }\r\n\r\n        this.debug(`Space '${this.spaceName}' had ${count} new pages`);\r\n    }\r\n\r\n    private async *processSpace(spaceKey: string) {\r\n        this.debug('Processing space', spaceKey);\r\n\r\n        try {\r\n            const spaceContent = await this.confluence.space.getContentForSpace({ spaceKey });\r\n            this.debug(`Confluence space '${spaceKey}' has '${spaceContent['page'].results.length}' root pages`);\r\n\r\n            for (const { id, title } of spaceContent['page'].results) {\r\n                for await (const result of this.processPage(id, title)) {\r\n                    yield result;\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.debug('Could not get space details', spaceKey, e);\r\n            return;\r\n        }\r\n    }\r\n\r\n    private async *processPage(pageId: string, title: string) {\r\n        this.debug('Processing page', title);\r\n        let confluenceVersion = 0;\r\n\r\n        try {\r\n            const pageProperties = await this.confluence.content.getContentById({\r\n                id: pageId,\r\n                expand: ['version', 'history'],\r\n            });\r\n\r\n            if (this.lastUpdatedFilter) {\r\n                const pageLastEditDate = new Date(pageProperties.history.lastUpdated.when);\r\n\r\n                if (pageLastEditDate > this.lastUpdatedFilter) {\r\n                    this.debug(`Page '${title}' has last edit date ${pageLastEditDate}. Continuing...`);\r\n                } else {\r\n                    this.debug(\r\n                        `Page '${title}' has last edit date ${pageLastEditDate}, which is less than filter date. Skipping...`,\r\n                    );\r\n                    return;\r\n                }\r\n            }\r\n\r\n            if (!pageProperties.version.number) throw new Error('Version number not found in page properties...');\r\n            confluenceVersion = pageProperties.version.number;\r\n        } catch (e) {\r\n            this.debug('Could not get page properties. Page will be SKIPPED!', title, e.response);\r\n            return;\r\n        }\r\n\r\n        let doProcess = false;\r\n        if (!(await this.checkInCache(pageId))) {\r\n            this.debug(`Processing '${title}' for the FIRST time...`);\r\n            doProcess = true;\r\n        } else {\r\n            const cacheVersion = (await this.getFromCache(pageId)).version;\r\n            if (cacheVersion !== confluenceVersion) {\r\n                this.debug(\r\n                    `For page '${title}' - version in cache is ${cacheVersion} and confluence version is ${confluenceVersion}. This page will be PROCESSED.`,\r\n                );\r\n                doProcess = true;\r\n            } else\r\n                this.debug(\r\n                    `For page '${title}' - version in cache and confluence are the same ${confluenceVersion}. This page will be SKIPPED.`,\r\n                );\r\n        }\r\n\r\n        if (!doProcess) {\r\n            this.debug(`Skipping page '${title}'`);\r\n            return;\r\n        }\r\n\r\n        try {\r\n            const content = await this.confluence.content.getContentById({\r\n                id: pageId,\r\n                expand: ['body', 'children.page', 'body.view'],\r\n            });\r\n\r\n            if (!content.body.view.value) {\r\n                this.debug(`Page '${pageId}' has empty content. Skipping...`);\r\n                return;\r\n            }\r\n\r\n            this.debug(`Processing content for page '${title}'...`);\r\n            for await (const result of this.getContentChunks(content.body.view.value, content._links.webui)) {\r\n                yield result;\r\n            }\r\n\r\n            await this.saveToCache(pageId, { version: confluenceVersion });\r\n\r\n            if (content.children) {\r\n                for (const { id, title } of content.children.page.results) {\r\n                    try {\r\n                        for await (const result of this.processPage(id, title)) {\r\n                            yield result;\r\n                        }\r\n                    } catch (e) {\r\n                        this.debug(`Error! Could not process page child '${title}'`, pageId, e);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n        } catch (e) {\r\n            this.debug('Error! Could not process page content', pageId, e);\r\n            return;\r\n        }\r\n    }\r\n\r\n    private async *getContentChunks(pageBody: string, pageUrl: string) {\r\n        const webLoader = new WebLoader({\r\n            urlOrContent: pageBody,\r\n            chunkSize: this.chunkSize,\r\n            chunkOverlap: this.chunkOverlap,\r\n        });\r\n\r\n        for await (const result of await webLoader.getUnfilteredChunks()) {\r\n            //remove all types of empty brackets from string\r\n            // eslint-disable-next-line no-useless-escape\r\n            result.pageContent = result.pageContent.replace(/[\\[\\]\\(\\)\\{\\}]/g, '');\r\n\r\n            yield {\r\n                pageContent: result.pageContent,\r\n                metadata: {\r\n                    type: 'ConfluenceLoader' as const,\r\n                    source: `${this.confluenceBaseUrl}/wiki${pageUrl}`,\r\n                },\r\n            };\r\n        }\r\n    }\r\n}\r\n"],
  "mappings": ";;;;;;;;;;;AAAA,OAAO,SAAS;AAChB,OAAO,yBAAyB;AAChC,SAAS,oBAAoB;AAF7B,IAQsB;AARtB;AAAA;AAQO,IAAe,aAAf,MAAe,oBAGZ,aAAa;AAAA,MACnB,OAAe;AAAA,MAEf,OAAc,SAAS,OAAkB;AACrC,oBAAW,QAAQ;AAAA,MACvB;AAAA,MAEmB;AAAA,MACA;AAAA,MACA;AAAA,MACH;AAAA,MACG;AAAA,MAEnB,YACI,UACA,gBACA,YAAY,GACZ,eAAe,GACf,uBAAuB,OACzB;AACE,cAAM;AAEN,aAAK,WAAW;AAChB,aAAK,YAAY;AACjB,aAAK,eAAe;AACpB,aAAK,iBAAiB;AACtB,aAAK,uBAAuB;AAE5B,4BAAoB,2BAA2B,EAAE,wCAAwC,QAAQ,EAAE;AAAA,MACvG;AAAA,MAEO,cAAsB;AACzB,eAAO,KAAK;AAAA,MAChB;AAAA;AAAA,MAGA,MAAa,OAAsB;AAAA,MAAC;AAAA;AAAA,MAG7B,YAAY,QAAmB;AAAA,MAAC;AAAA,MAEvC,MAAc,oBAAoB,iBAAyB;AACvD,YAAI,CAAC,YAAW;AAAO;AAEvB,cAAM,aAAa;AAAA,UACf,UAAU,KAAK;AAAA,UACf,MAAM,KAAK,YAAY;AAAA,UACvB,gBAAgB,KAAK;AAAA,UACrB;AAAA,QACJ;AAEA,cAAM,YAAW,MAAM,kBAAkB,KAAK,UAAU,UAAU;AAAA,MACtE;AAAA,MAEQ,kBAAkB,KAAa;AACnC,eAAO,iBAAiB,KAAK,QAAQ,IAAI,GAAG;AAAA,MAChD;AAAA,MAEA,MAAgB,aAAa,KAAa;AACtC,YAAI,CAAC,YAAW;AAAO,iBAAO;AAC9B,eAAO,YAAW,MAAM,gBAAgB,KAAK,kBAAkB,GAAG,CAAC;AAAA,MACvE;AAAA,MAEA,MAAgB,aAAa,KAAqC;AAC9D,YAAI,CAAC,YAAW;AAAO,iBAAO;AAC9B,eAAO,YAAW,MAAM,gBAAgB,KAAK,kBAAkB,GAAG,CAAC;AAAA,MACvE;AAAA,MAEA,MAAgB,YAAY,KAAa,OAAsB;AAC3D,YAAI,CAAC,YAAW;AAAO;AACvB,cAAM,YAAW,MAAM,gBAAgB,KAAK,UAAU,KAAK,kBAAkB,GAAG,GAAG,KAAK;AAAA,MAC5F;AAAA,MAEA,MAAgB,gBAAgB,KAAa;AACzC,YAAI,CAAC,YAAW;AAAO,iBAAO;AAC9B,eAAO,YAAW,MAAM,mBAAmB,KAAK,kBAAkB,GAAG,CAAC;AAAA,MAC1E;AAAA,MAEA,MAAgB,qBACZ,sBACF;AACE,aAAK,KAAK,6BAA6B,oBAAoB;AAAA,MAC/D;AAAA;AAAA;AAAA;AAAA;AAAA,MAMA,OAAc,YAAuE;AACjF,cAAM,SAAS,MAAM,KAAK,oBAAoB;AAE9C,YAAI,QAAQ;AACZ,yBAAiB,SAAS,QAAQ;AAC9B,gBAAM,cAAc,MAAM,YACrB,QAAQ,kBAAkB,GAAG,EAC7B,QAAQ,UAAU,GAAG,EACrB,KAAK;AAEV,cAAI,MAAM,YAAY,SAAS,GAAG;AAC9B,kBAAM;AAAA,cACF,GAAG;AAAA,cACH,aAAa,IAAI,MAAM,WAAW;AAAA,YACtC;AACA;AAAA,UACJ;AAAA,QACJ;AAEA,cAAM,KAAK,oBAAoB,KAAK;AAAA,MACxC;AAAA,IAGJ;AAAA;AAAA;;;AC1HA,IAAsB;AAAtB;AAAA;AAAO,IAAe,iBAAf,MAA8B;AAAA;AAAA,MAEjC,MAAa,OAAsB;AAAA,MAAC;AAAA,IAKxC;AAAA;AAAA;;;ACPA,SAAS,cAAc,WAAW,qBAAqB;AACvD,OAAOA,0BAAyB;AAChC,SAAS,MAAM,cAAc;AAF7B,IAOsB;AAPtB;AAAA;AAOO,IAAe,YAAf,MAAe,WAAU;AAAA,MACX,YAAYA,qBAAoB,yBAAyB;AAAA,MAE1E,OAAe;AAAA,MACf,OAAe;AAAA,MAEf,OAAc,sBAAsB,aAAsB;AACtD,mBAAU,qBAAqB;AAAA,MACnC;AAAA,MAEA,OAAc,SAAS,OAAkB;AACrC,mBAAU,QAAQ;AAAA,MACtB;AAAA,MAEiB;AAAA,MAEjB,YAAY,aAAsB;AAC9B,aAAK,eAAe;AAAA,MACxB;AAAA,MAEA,IAAW,cAAc;AACrB,eAAO,KAAK,gBAAgB,WAAU;AAAA,MAC1C;AAAA;AAAA,MAGA,MAAa,OAAsB;AAAA,MAAC;AAAA,MAE5B,qBAAqB,mBAA4C;AACrE,cAAM,gBAAgB,oBAAI,IAA0B;AAEpD,0BAAkB,QAAQ,CAAC,SAAS;AAChC,gBAAM,EAAE,SAAS,IAAI;AACrB,cAAI,YAAY,SAAS,QAAQ;AAE7B,gBAAI,CAAC,cAAc,IAAI,SAAS,MAAM,GAAG;AACrC,4BAAc,IAAI,SAAS,QAAQ;AAAA,gBAC/B,QAAQ,SAAS;AAAA,gBACjB,UAAU,SAAS;AAAA;AAAA,cACvB,CAAC;AAAA,YACL;AAAA,UACJ;AAAA,QACJ,CAAC;AAGD,eAAO,MAAM,KAAK,cAAc,OAAO,CAAC;AAAA,MAC5C;AAAA,MAEA,MAAa,QACT,QACA,WACA,mBACA,mBACqD;AACrD,cAAM,WAAyD,CAAC,IAAI,cAAc,MAAM,CAAC;AACzF,iBAAS;AAAA,UACL,IAAI,cAAc,uBAAuB,kBAAkB,IAAI,CAAC,MAAM,EAAE,WAAW,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,QACrG;AAEA,iBAAS;AAAA,UACL,GAAG,kBAAkB,IAAI,CAAC,MAAM;AAC5B,gBAAI,EAAE,UAAU;AAAM,qBAAO,IAAI,UAAU,EAAE,SAAS,EAAE,QAAQ,CAAC;AAAA,qBACxD,EAAE,UAAU;AAAU,qBAAO,IAAI,cAAc,EAAE,SAAS,EAAE,QAAQ,CAAC;AAAA;AACzE,qBAAO,IAAI,aAAa,EAAE,SAAS,EAAE,QAAQ,CAAC;AAAA,UACvD,CAAC;AAAA,QACL;AACA,iBAAS,KAAK,IAAI,aAAa,GAAG,SAAS,GAAG,CAAC;AAC/C,eAAO;AAAA,MACX;AAAA,MAEA,MAAa,MACT,QACA,WACA,mBACA,gBACA,mBACA,UACA,gBACsB;AACtB,YAAI;AAEJ,YAAI,gBAAgB;AAChB,cAAI,CAAE,MAAM,WAAU,MAAM,gBAAgB,cAAc,GAAI;AAC1D,iBAAK,UAAU,yBAAyB,cAAc,UAAU;AAChE,kBAAM,WAAU,MAAM,gBAAgB,cAAc;AAAA,UACxD;AAEA,yBAAe,MAAM,WAAU,MAAM,gBAAgB,cAAc;AACnE,eAAK;AAAA,YACD,GAAG,aAAa,QAAQ,MAAM,8CAA8C,cAAc;AAAA,UAC9F;AAGA,cAAI,qBAAqB,aAAa,QAAQ,SAAS,GAAG;AACtD,gBAAI,kBAAkB,eAAe,SAAS;AAC9C,gBAAI,OAAO;AACX,qBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,SAAS,GAAG,KAAK;AACtD,kBAAI,IAAI,aAAa,QAAQ,CAAC;AAC9B,qBAAO,OAAO,EAAE,QAAQ,OAAO,EAAE,UAAU;AAAA,YAC/C;AACA,gBAAI,aAAa,eAAe,IAAI;AACpC,mBAAO,aAAa,QAAQ,SAAS,KAAK,aAAa,kBAAkB,mBAAmB;AACxF,2BAAa,QAAQ,MAAM;AAC3B,qBAAO;AACP,uBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,SAAS,GAAG,KAAK;AACtD,oBAAI,IAAI,aAAa,QAAQ,CAAC;AAC9B,uBAAO,OAAO,EAAE,QAAQ,OAAO,EAAE,UAAU;AAAA,cAC/C;AACA,2BAAa,eAAe,IAAI;AAAA,YACpC;AAAA,UACJ;AAGA,gBAAM,WAAU,MAAM,uBAAuB,gBAAgB;AAAA,YACzD,IAAI,OAAO;AAAA,YACX,WAAW,oBAAI,KAAK;AAAA,YACpB,OAAO;AAAA,YACP,SAAS;AAAA,UACb,CAAC;AAAA,QACL,OAAO;AACH,eAAK,UAAU,oEAAoE;AACnF,yBAAe,EAAE,gBAAgB,WAAW,SAAS,CAAC,EAAE;AAAA,QAC5D;AAEA,cAAM,WAAW,MAAM,KAAK,QAAQ,QAAQ,WAAW,mBAAmB,aAAa,QAAQ,MAAM,GAAG,EAAE,CAAC;AAC3G,cAAM,gBAAgB,KAAK,qBAAqB,iBAAiB;AACjE,cAAM,YAAY,oBAAI,KAAK;AAC3B,cAAM,KAAK,OAAO;AAGlB,cAAM,WAAW,MAAM,KAAK,SAAS,UAAU,QAAQ;AAEvD,cAAM,WAAoB;AAAA,UACtB;AAAA,UACA;AAAA,UACA,SAAS,SAAS;AAAA,UAClB,OAAO;AAAA,UACP,SAAS;AAAA,QACb;AAEA,YAAI,gBAAgB;AAEhB,gBAAM,WAAU,MAAM,uBAAuB,gBAAgB,QAAQ;AAAA,QACzE;AAEA,eAAO;AAAA,UACH,GAAG;AAAA,UACH,UAAU;AAAA,YACN,aAAa,SAAS,UAAU,eAAe;AAAA,YAC/C,cAAc,SAAS,UAAU,gBAAgB;AAAA,UACrD;AAAA,QACJ;AAAA,MACJ;AAAA,MAEA,MAAa,YAAY,UAAwD;AAC7E,cAAM,WAAW,MAAM,KAAK,SAAS,QAAQ;AAE7C,eAAO;AAAA,UACH,QAAQ,SAAS;AAAA,UACjB,UAAU;AAAA,YACN,aAAa,SAAS,UAAU,eAAe;AAAA,YAC/C,cAAc,SAAS,UAAU,gBAAgB;AAAA,UACrD;AAAA,QACJ;AAAA,MACJ;AAAA,IAMJ;AAAA;AAAA;;;AChLA;AAAA;AAAA;AAAA;;;ACAA,IAAa;AAAb;AAAA;AAAO,IAAM,4BAA4B;AAAA;AAAA;;;ACAzC;AAAA;AAAA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;;;ACYO,SAAS,UAA4B,OAAiB,GAAW;AACpE,QAAM,OAAO,CAAC;AACd,SAAO,MAAM,OAAO,SAAU,MAAM;AAChC,WAAO,OAAO,UAAU,eAAe,KAAK,MAAM,KAAK,CAAC,EAAE,CAAC,IAAI,QAAS,KAAK,KAAK,CAAC,EAAE,CAAC,IAAI;AAAA,EAC9F,CAAC;AACL;AAxBA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;;;ACAA;AAAA;AAAA;AAAA;;;ACEO,SAAS,qBAAqB,SAAiB,QAAgB,WAAoB;AACtF,MAAI,QAAQ,UAAU;AAAQ,WAAO;AAErC,cAAY,aAAa;AAEzB,QAAM,SAAS,UAAU,QACrB,cAAc,SAAS,QACvB,aAAa,KAAK,KAAK,cAAc,CAAC,GACtC,YAAY,KAAK,MAAM,cAAc,CAAC;AAE1C,SAAO,QAAQ,OAAO,GAAG,UAAU,IAAI,YAAY,QAAQ,OAAO,QAAQ,SAAS,SAAS;AAChG;AAEO,SAAS,YAAY,MAAc;AACtC,SAAO,KAAK,QAAQ,OAAO,EAAE;AAC7B,SAAO,KAAK,QAAQ,MAAM,GAAG;AAC7B,SAAO,KAAK,QAAQ,UAAU,GAAG;AACjC,SAAO,KAAK,QAAQ,UAAU,GAAG;AACjC,SAAO,KAAK,QAAQ,kBAAkB,GAAG;AAEzC,SAAO,KAAK,KAAK;AACrB;AAoBO,SAAS,WAAW,cAAsB;AAC7C,MAAI;AACA,UAAM,MAAM,IAAI,IAAI,YAAY;AAChC,WAAO,IAAI,aAAa,WAAW,IAAI,aAAa;AAAA,EACxD,QAAQ;AACJ,WAAO;AAAA,EACX;AACJ;AAlDA;AAAA;AAAA;AAAA;;;ACAA,OAAOC,0BAAyB;AAsBhC,eAAsB,QAClB,KACA,SAC+C;AAC/C,QAAM,UAAU,SAAS,WAAW,CAAC;AACrC,UAAQ,YAAY,IAAI,QAAQ,YAAY,KAAK;AAEjD,QAAM,SAAS,SAAS,UAAU;AAClC,QAAM,WAAW,MAAM,MAAM,KAAK,EAAE,QAAQ,CAAC;AAC7C,EAAAA,qBAAoB,sBAAsB,EAAE,QAAQ,GAAG,0BAA0B,SAAS,MAAM,EAAE;AAClG,MAAI,SAAS,WAAW;AAAK,UAAM,IAAI,MAAM,wBAAwB,GAAG,sBAAsB,SAAS,MAAM,GAAG;AAEhH,SAAO;AAAA,IACH,MACI,WAAW,SACL,MAAM,SAAS,KAAK,IACpB,WAAW,WACT,OAAO,KAAK,MAAM,SAAS,YAAY,CAAC,IACvC,SAAS;AAAA,IACtB,YAAY,SAAS;AAAA,IACrB,SAAS,SAAS;AAAA,EACtB;AACJ;AA5CA,IAEM;AAFN;AAAA;AAEA,IAAM,qBACF;AAAA;AAAA;;;ACHJ,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;;;ACJA,OAAOC,0BAAyB;AAChC,SAAS,kBAAkB;AAD3B,IAKa;AALb;AAAA;AAGA;AAEO,IAAM,SAAN,cAAqB,UAAU;AAAA,MAIlC,YAA6B,eAA4D;AACrF,cAAM,cAAc,WAAW;AADN;AAAA,MAE7B;AAAA,MALiB,QAAQA,qBAAoB,sBAAsB;AAAA,MAC3D;AAAA,MAMR,MAAe,OAAsB;AACjC,aAAK,QAAQ,IAAI,WAAW,KAAK,aAAa;AAAA,MAClD;AAAA,MAEA,MAAe,SACX,UACA,UACsB;AACtB,aAAK,MAAM,wCAAwC,SAAS,SAAS,SAAS,CAAC,EAAE,OAAO;AAExF,YAAI,UAAU;AACV,gBAAM,SAAS,MAAM,KAAK,MAAM,OAAO,QAAQ;AAE/C,gBAAM,SAAS,CAAC;AAChB,2BAAiB,SAAS,QAAQ;AAC9B,mBAAO,KAAK,KAAK;AACjB,qBAAS,KAAK;AAAA,UAClB;AAEA,cAAI,MAAM,OAAO,KAAK,EAAE;AACxB,iBAAO;AAAA,YACH,QAAQ;AAAA,UACZ;AAAA,QACJ,OAAO;AACH,gBAAM,SAAS,MAAM,KAAK,MAAM,OAAO,QAAQ;AAC/C,eAAK,MAAM,qBAAqB,MAAM;AAEtC,iBAAO;AAAA,YACH,QAAQ,OAAO,QAAQ,SAAS;AAAA,YAChC,UAAU;AAAA,cACN,aAAa,OAAO,kBAAkB,WAAW;AAAA,cACjD,cAAc,OAAO,kBAAkB,WAAW;AAAA,YACtD;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA;AAAA;;;ACjDA,OAAOC,0BAAyB;AAChC,SAAS,uBAAuB;AADhC,IAKa;AALb;AAAA;AAGA;AAEO,IAAM,cAAN,cAA0B,UAAU;AAAA,MAIvC,YAA6B,eAAiE;AAC1F,cAAM,cAAc,WAAW;AADN;AAAA,MAE7B;AAAA,MALiB,QAAQA,qBAAoB,sBAAsB;AAAA,MAC3D;AAAA,MAMR,MAAe,OAAsB;AACjC,aAAK,QAAQ,IAAI,gBAAgB,KAAK,aAAa;AAAA,MACvD;AAAA,MAEA,MAAe,SAAS,UAAgF;AACpG,aAAK,MAAM,8CAA8C,SAAS,SAAS,SAAS,CAAC,EAAE,OAAO;AAC9F,cAAM,SAAS,MAAM,KAAK,MAAM,OAAO,QAAQ;AAC/C,aAAK,MAAM,2BAA2B,MAAM;AAE5C,eAAO;AAAA,UACH,QAAQ,OAAO,QAAQ,SAAS;AAAA,UAChC,UAAU;AAAA,YACN,aAAa,OAAO,kBAAkB,WAAW;AAAA,YACjD,cAAc,OAAO,kBAAkB,WAAW;AAAA,UACtD;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA;AAAA;;;AC9BA,SAAS,yBAAyB,sCAAsC;AAAxE,IAGa;AAHb;AAAA;AACA;AAEO,IAAM,wBAAN,cAAoC,eAAe;AAAA,MAGtD,YAA6B,eAAiF;AAC1G,cAAM;AADmB;AAEzB,YAAI,CAAC,KAAK;AAAe,eAAK,gBAAgB,CAAC;AAC/C,YAAI,CAAC,KAAK,cAAc;AAAO,eAAK,cAAc,QAAQ;AAE1D,YAAI,CAAC,KAAK,cAAc,YAAY;AAChC,cAAI,KAAK,cAAc,UAAU,0BAA0B;AACvD,iBAAK,cAAc,aAAa;AAAA,UACpC,WAAW,KAAK,cAAc,UAAU,0BAA0B;AAC9D,iBAAK,cAAc,aAAa;AAAA,UACpC,WAAW,KAAK,cAAc,UAAU,0BAA0B;AAC9D,iBAAK,cAAc,aAAa;AAAA,UACpC,OAAO;AACH,kBAAM,IAAI,MAAM,sEAAsE;AAAA,UAC1F;AAAA,QACJ;AAEA,aAAK,QAAQ,IAAI,+BAA+B,KAAK,aAAa;AAAA,MACtE;AAAA,MApBQ;AAAA,MAsBR,MAAe,gBAAiC;AAC5C,eAAO,KAAK,cAAc;AAAA,MAC9B;AAAA,MAEA,MAAe,eAAe,OAAsC;AAChE,eAAO,KAAK,MAAM,eAAe,KAAK;AAAA,MAC1C;AAAA,MAEA,MAAe,WAAW,MAAiC;AACvD,eAAO,KAAK,MAAM,WAAW,IAAI;AAAA,MACrC;AAAA,IACJ;AAAA;AAAA;;;ACrCA,SAAS,wBAAwB;AAAjC,IAGa;AAHb;AAAA;AACA;AAEO,IAAM,mBAAN,cAA+B,eAAe;AAAA,MAGjD,YAA6B,eAAmE;AAC5F,cAAM;AADmB;AAEzB,YAAI,CAAC,KAAK;AAAe,eAAK,gBAAgB,CAAC;AAC/C,YAAI,CAAC,KAAK,cAAc;AAAO,eAAK,cAAc,QAAQ;AAE1D,YAAI,CAAC,KAAK,cAAc,YAAY;AAChC,cAAI,KAAK,cAAc,UAAU,0BAA0B;AACvD,iBAAK,cAAc,aAAa;AAAA,UACpC,WAAW,KAAK,cAAc,UAAU,0BAA0B;AAC9D,iBAAK,cAAc,aAAa;AAAA,UACpC,WAAW,KAAK,cAAc,UAAU,0BAA0B;AAC9D,iBAAK,cAAc,aAAa;AAAA,UACpC,OAAO;AACH,kBAAM,IAAI,MAAM,sEAAsE;AAAA,UAC1F;AAAA,QACJ;AAEA,aAAK,QAAQ,IAAI,iBAAiB,KAAK,aAAa;AAAA,MACxD;AAAA,MApBQ;AAAA,MAsBR,MAAe,gBAAiC;AAC5C,eAAO,KAAK,cAAc;AAAA,MAC9B;AAAA,MAEA,MAAe,eAAe,OAAsC;AAChE,eAAO,KAAK,MAAM,eAAe,KAAK;AAAA,MAC1C;AAAA,MAEA,MAAe,WAAW,MAAiC;AACvD,eAAO,KAAK,MAAM,WAAW,IAAI;AAAA,MACrC;AAAA,IACJ;AAAA;AAAA;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAAC,YAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;;;ACHA,SAAS,kCAAAC,uCAAsC;AAC/C,OAAOC,2BAAyB;AAChC,SAAS,eAAe;AACxB,OAAOC,UAAS;AAHhB,IAQa;AARb;AAAA;AAKA;AACA,IAAAC;AAEO,IAAM,YAAN,cAAwB,WAAkC;AAAA,MAC5C,QAAQF,sBAAoB,0BAA0B;AAAA,MACtD;AAAA,MACA;AAAA,MAEjB,YAAY;AAAA,QACR;AAAA,QACA;AAAA,QACA;AAAA,MACJ,GAIG;AACC,cAAM,aAAaC,KAAI,YAAY,CAAC,IAAI,EAAE,aAAa,GAAG,aAAa,KAAM,gBAAgB,CAAC;AAE9F,aAAK,QAAQ,WAAW,YAAY,IAAI,OAAO;AAC/C,aAAK,eAAe;AAAA,MACxB;AAAA,MAEA,OAAgB,sBAAsB;AAClC,cAAM,UAAU,IAAIF,gCAA+B;AAAA,UAC/C,WAAW,KAAK;AAAA,UAChB,cAAc,KAAK;AAAA,QACvB,CAAC;AAED,YAAI;AACA,gBAAM,OAAO,KAAK,SAAS,MAAM,QAAQ,KAAK,cAAc,EAAE,QAAQ,OAAO,CAAC,GAAG,OAAO,KAAK;AAE7F,gBAAM,OAAO,QAAQ,MAAM;AAAA,YACvB,UAAU;AAAA,YACV,kBAAkB;AAAA,UACtB,CAAC,EAAE,QAAQ,+BAA+B,EAAE;AAE5C,gBAAM,uBAAuB,KAAK,QAAQ,SAAY,qBAAqB,KAAK,cAAc,EAAE;AAEhG,gBAAM,SAAS,MAAM,QAAQ,UAAU,YAAY,IAAI,CAAC;AACxD,qBAAW,SAAS,QAAQ;AACxB,kBAAM;AAAA,cACF,aAAa;AAAA,cACb,UAAU;AAAA,gBACN,MAAM;AAAA,gBACN,QAAQ,KAAK,QAAQ,KAAK,eAAe;AAAA,cAC7C;AAAA,YACJ;AAAA,UACJ;AAAA,QACJ,SAAS,GAAG;AACR,eAAK,MAAM,yBAAyB,KAAK,cAAc,CAAC;AAAA,QAC5D;AAAA,MACJ;AAAA,IACJ;AAAA;AAAA;;;AC1DA,IAAAI,YAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,OAAO;AACP,OAAO,UAAU;;;ACEjB;AAcAC;AAjBA,OAAOC,0BAAyB;AAmBzB,IAAM,iBAAN,MAAqB;AAAA,EACP,QAAQA,qBAAoB,cAAc;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACT;AAAA,EACA;AAAA,EAER,YAAY,YAAmC;AAC3C,QAAI,CAAC,WAAW,kBAAkB;AAAG,YAAM,IAAI,MAAM,8BAA8B;AACnF,SAAK,iBAAiB,WAAW,kBAAkB;AAEnD,SAAK,oCAAoC,WAAW,0CAA0C;AAC9F,SAAK,QAAQ,WAAW,SAAS;AACjC,eAAW,SAAS,KAAK,KAAK;AAC9B,cAAU,SAAS,KAAK,KAAK;AAE7B,SAAK,gBAAgB,YAAY,WAAW,iBAAiB,CAAC;AAC9D,SAAK,MAAM,kCAAkC,KAAK,aAAa,GAAG;AAElE,SAAK,iBAAiB,WAAW,kBAAkB;AACnD,QAAI,CAAC,KAAK;AAAgB,YAAM,IAAI,YAAY,wBAAwB;AAExE,SAAK,oBAAoB,WAAW,qBAAqB;AACzD,SAAK,2BAA2B,WAAW,4BAA4B;AAAA,EAC3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,KAAK,YAAmC;AACjD,UAAM,KAAK,eAAe,KAAK;AAE/B,SAAK,QAAQ,MAAM,KAAK,SAAS,WAAW,SAAS,CAAC;AACtD,QAAI,CAAC,KAAK;AAAO,WAAK,MAAM,gDAAgD;AAAA;AACvE,gBAAU,sBAAsB,WAAW,eAAe,CAAC;AAEhE,SAAK,UAAU,WAAW,WAAW;AAErC,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK,MAAM,KAAK;AACtB,WAAK,MAAM,uBAAuB;AAAA,IACtC;AAEA,UAAM,KAAK,eAAe,KAAK,EAAE,YAAY,MAAM,KAAK,eAAe,cAAc,EAAE,CAAC;AACxF,SAAK,MAAM,6BAA6B;AAExC,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK,MAAM,KAAK;AACtB,WAAK,MAAM,mBAAmB;AAAA,IAClC;AAEA,SAAK,UAAU,UAAU,KAAK,SAAS,aAAa;AACpD,qBAAiB,UAAU,KAAK,SAAS;AACrC,YAAM,KAAK,UAAU,MAAM;AAAA,IAC/B;AACA,SAAK,MAAM,yBAAyB;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAc,SAAS,OAA6D;AAChF,QAAI,OAAO,UAAU;AAAU,aAAO;AAAA,aAC7B,UAAU;AAAM,aAAO;AAAA,SAC3B;AACD,YAAM,EAAE,QAAAC,QAAO,IAAI,MAAM,yDAAoC,MAAM,MAAM;AACrE,cAAM,IAAI,MAAM,gFAAgF;AAAA,MACpG,CAAC;AACD,WAAK,MAAM,6BAA6B;AAExC,UAAI;AAAuC,eAAO,IAAIA,QAAO,EAAE,WAAW,SAAS,CAAC;AAAA,eAC3E;AAA8C,eAAO,IAAIA,QAAO,EAAE,WAAW,cAAc,CAAC;AAAA,eAC5F;AAAgD,eAAO,IAAIA,QAAO,EAAE,WAAW,gBAAgB,CAAC;AAAA;AACpG,cAAM,IAAI,MAAM,oBAAoB;AAAA,IAC7C;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAc,YAAY,QAAsC;AAC5D,UAAM,QAAQ,OAAO,IAAI,CAAC,EAAE,YAAY,MAAM,WAAW;AACzD,WAAO,KAAK,eAAe,eAAe,KAAK;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWQ,iBAAiB,gBAAwB,aAAqB;AAClE,WAAO,GAAG,cAAc,IAAI,WAAW;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAa,UAAU,aAAyB,cAAc,OAAiC;AAC3F,WAAO,KAAK,WAAW,aAAa,WAAW;AAAA,EACnD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,MAAc,WAAW,QAAoB,aAAgD;AACzF,UAAM,WAAW,OAAO,YAAY;AACpC,SAAK,MAAM,oBAAoB,QAAQ;AACvC,QAAI,KAAK;AAAO,aAAO,YAAY,KAAK,KAAK;AAE7C,QAAI,KAAK,SAAU,MAAM,KAAK,MAAM,kBAAkB,QAAQ,GAAI;AAC9D,UAAI,aAAa;AACb,cAAM,EAAE,gBAAgB,IAAI,MAAM,KAAK,MAAM,kBAAkB,QAAQ;AAEvE,aAAK;AAAA,UACD,gEAAgE,eAAe;AAAA,UAC/E;AAAA,QACJ;AAEA,aAAK,UAAU,KAAK,QAAQ,OAAO,CAAC,MAAM,EAAE,YAAY,KAAK,OAAO,YAAY,CAAC;AACjF,YAAI,kBAAkB;AAAG,gBAAM,KAAK,aAAa,QAAQ;AAAA,MAC7D,OAAO;AACH,aAAK,MAAM,sCAAsC,QAAQ;AACzD,eAAO,EAAE,cAAc,GAAG,UAAU,YAAY,OAAO,YAAY,KAAK;AAAA,MAC5E;AAAA,IACJ;AAEA,UAAM,OAAO,KAAK;AAClB,UAAM,SAAS,MAAM,OAAO,UAAU;AAEtC,SAAK,MAAM,6BAA6B,QAAQ;AAChD,UAAM,EAAE,WAAW,IAAI,MAAM,KAAK,gBAAgB,UAAU,MAAM;AAClE,SAAK,MAAM,6BAA6B,UAAU,oBAAoB,QAAQ;AAE9E,QAAI,OAAO,sBAAsB;AAC7B,WAAK,MAAM,kCAAkC,QAAQ;AAErD,aAAO,GAAG,6BAA6B,OAAO,yBAAyB;AACnE,cAAM,KAAK,kBAAkB,UAAU,oBAAoB;AAAA,MAC/D,CAAC;AAAA,IACL;AAEA,SAAK,QAAQ,KAAK,MAAM;AACxB,SAAK,MAAM,cAAc,QAAQ,eAAe;AAChD,WAAO,EAAE,cAAc,YAAY,UAAU,YAAY,OAAO,YAAY,KAAK;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAc,kBAAkB,UAAkB,sBAA+D;AAC7G,SAAK,MAAM,wCAAwC,QAAQ;AAC3D,UAAM,EAAE,WAAW,IAAI,MAAM,KAAK,gBAAgB,UAAU,oBAAoB;AAChF,SAAK,MAAM,GAAG,UAAU,oCAAoC,QAAQ;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,aAAa;AACtB,QAAI,CAAC,KAAK;AAAO,aAAO,CAAC;AACzB,WAAO,KAAK,MAAM,qBAAqB;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAc,gBAAgB,UAAkB,WAAoD;AAChG,QAAI,IAAI,GACJ,YAAY,GACZ,aAAa,GACb,kBAA2B,CAAC;AAEhC,qBAAiB,SAAS,WAAW;AACjC;AAEA,YAAM,iBAAiB;AAAA,QACnB,aAAa,MAAM;AAAA,QACnB,UAAU;AAAA,UACN,GAAG,MAAM;AAAA,UACT,gBAAgB;AAAA,UAChB,IAAI,KAAK,iBAAiB,UAAU,GAAG;AAAA,QAC3C;AAAA,MACJ;AACA,sBAAgB,KAAK,cAAc;AAEnC,UAAI,YAAY,8BAA8B,GAAG;AAC7C,sBAAc,MAAM,KAAK,oBAAoB,UAAU,eAAe;AACtE,0BAAkB,CAAC;AACnB,oBAAY;AAAA,MAChB;AAAA,IACJ;AAEA,kBAAc,MAAM,KAAK,oBAAoB,UAAU,eAAe;AACtE,WAAO,EAAE,YAAY,gBAAgB;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,MAAc,oBAAoB,gBAAwB,iBAA0B;AAChF,QAAI,gBAAgB,WAAW;AAAG,aAAO;AAEzC,SAAK,MAAM,0BAA0B,gBAAgB,MAAM,gBAAgB,cAAc,EAAE;AAC3F,UAAM,aAAa,MAAM,KAAK,YAAY,eAAe;AACzD,SAAK,MAAM,0BAA0B,gBAAgB,MAAM,yBAAyB,cAAc,EAAE;AAEpG,UAAM,cAAc,gBAAgB,IAAI,CAAC,OAAO,UAAU;AACtD,aAAwB;AAAA,QACpB,aAAa,MAAM;AAAA,QACnB,QAAQ,WAAW,KAAK;AAAA,QACxB,UAAU,MAAM;AAAA,MACpB;AAAA,IACJ,CAAC;AAED,SAAK,MAAM,+BAA+B,cAAc,oBAAoB;AAC5E,WAAO,KAAK,eAAe,aAAa,WAAW;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,qBAAsC;AAC/C,WAAO,KAAK,eAAe,eAAe;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,mBAAmB,gBAAwB;AACpD,QAAI,KAAK,OAAO;AACZ,YAAM,KAAK,MAAM,mBAAmB,cAAc;AAAA,IACtD;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,aAAa,gBAAwB;AAC9C,UAAM,eAAe,MAAM,KAAK,eAAe,WAAW,cAAc;AACxE,QAAI,KAAK,SAAS;AAAc,YAAM,KAAK,MAAM,oCAAoC,cAAc;AACnG,SAAK,UAAU,KAAK,QAAQ,OAAO,CAAC,MAAM,EAAE,YAAY,KAAK,cAAc;AAC3E,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAQ;AACjB,UAAM,KAAK,eAAe,MAAM;AAChC,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAa,cAAc,YAAoB,cAAuB;AAClE,UAAM,gBAAgB,MAAM,KAAK,eAAe,WAAW,UAAU;AACrE,UAAM,sBAAsB,MAAM,KAAK,eAAe;AAAA,MAClD;AAAA,MACA,KAAK,oBAAoB;AAAA,MACzB;AAAA,IACJ;AACA,SAAK,MAAM,qBAAqB,oBAAoB,MAAM,+BAA+B;AAEzF,WAAO,oBACF,OAAO,CAAC,WAAW,OAAO,QAAQ,KAAK,wBAAwB,EAC/D,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK,EAChC,MAAM,GAAG,KAAK,iBAAiB;AAAA,EACxC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,OAAO,OAAe,cAAuB;AACtD,UAAM,aAAa,YAAY,KAAK;AACpC,UAAM,aAAa,MAAM,KAAK,cAAc,YAAY,YAAY;AAEpE,WAAO,CAAC,GAAG,IAAI,IAAI,WAAW,IAAI,CAAC,SAAS,CAAC,KAAK,aAAa,IAAI,CAAC,CAAC,EAAE,OAAO,CAAC;AAAA,EACnF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBA,MAAa,MACT,WACA,SACsB;AACtB,QAAI,CAAC,KAAK,OAAO;AACb,YAAM,IAAI,MAAM,yCAAyC;AAAA,IAC7D;AAEA,QAAI,UAAU,SAAS;AACvB,QAAI,CAAC;AAAS,gBAAU,MAAM,KAAK,OAAO,SAAS;AAEnD,QAAI,iBAAiB,SAAS;AAC9B,QAAI,CAAC,kBAAkB,KAAK,mCAAmC;AAC3D,uBAAiB;AAAA,IACrB;AAEA,UAAM,UAAU,CAAC,GAAG,IAAI,IAAI,QAAQ,IAAI,CAAC,UAAU,MAAM,SAAS,MAAM,CAAC,CAAC;AAC1E,SAAK;AAAA,MACD,qBAAqB,QAAQ,MAAM,0CAA0C,QAAQ,MAAM;AAAA,IAC/F;AAEA,WAAO,KAAK,MAAM;AAAA,MACd,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,SAAS;AAAA,MACT,SAAS;AAAA,IACb;AAAA,EACJ;AACJ;;;ACjbA;;;ACEO,IAAM,cAAN,MAAuC;AAAA,EAClC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,MAAM,OAAsB;AACxB,SAAK,aAAa,CAAC;AACnB,SAAK,qBAAqB,CAAC;AAC3B,SAAK,gBAAgB,oBAAI,IAAI;AAC7B,SAAK,wBAAwB,oBAAI,IAAI;AAAA,EACzC;AAAA,EAEA,MAAM,kBAAkB,UAAkB,OAAuC;AAC7E,SAAK,WAAW,QAAQ,IAAI;AAAA,EAChC;AAAA,EAEA,MAAM,kBAAkB,UAA4C;AAChE,WAAO,KAAK,WAAW,QAAQ;AAAA,EACnC;AAAA,EAEA,MAAM,kBAAkB,UAAoC;AACxD,WAAO,CAAC,CAAC,KAAK,WAAW,QAAQ;AAAA,EACrC;AAAA,EAEA,MAAM,uBAAmD;AACrD,WAAO,OAAO,OAAO,KAAK,UAAU;AAAA,EACxC;AAAA,EAEA,MAAM,gBAAmD,UAAkB,KAAa,OAAyB;AAC7G,QAAI,CAAC,KAAK,sBAAsB,IAAI,QAAQ;AAAG,WAAK,sBAAsB,IAAI,UAAU,CAAC,CAAC;AAC1F,SAAK,sBAAsB,IAAI,QAAQ,EAAE,KAAK,GAAG;AAEjD,SAAK,mBAAmB,GAAG,IAAI,EAAE,GAAG,OAAO,SAAS;AAAA,EACxD;AAAA,EAEA,MAAM,gBAAmD,KAAyB;AAC9E,UAAM,OAAiC,KAAK,mBAAmB,GAAG;AAClE,WAAO,KAAK;AACZ,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,gBAAgB,KAA+B;AACjD,WAAO,CAAC,CAAC,KAAK,mBAAmB,GAAG;AAAA,EACxC;AAAA,EAEA,MAAM,mBAAmB,KAA4B;AACjD,UAAM,WAAmB,KAAK,mBAAmB,GAAG,EAAE;AAEtD,WAAO,KAAK,WAAW,GAAG;AAE1B,QAAI,KAAK,sBAAsB,IAAI,QAAQ,GAAG;AAC1C,WAAK,sBAAsB;AAAA,QACvB;AAAA,QACA,KAAK,sBAAsB,IAAI,QAAQ,EAAE,OAAO,CAAC,MAAM,MAAM,GAAG;AAAA,MACpE;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,MAAM,oCAAoC,UAAiC;AACvE,QAAI,KAAK,sBAAsB,IAAI,QAAQ,GAAG;AAC1C,WAAK,sBAAsB,IAAI,QAAQ,EAAE,QAAQ,CAAC,QAAQ;AACtD,eAAO,KAAK,mBAAmB,GAAG;AAAA,MACtC,CAAC;AAAA,IACL;AAEA,SAAK,sBAAsB,OAAO,QAAQ;AAC1C,WAAO,KAAK,WAAW,QAAQ;AAAA,EACnC;AAAA,EAEA,MAAM,gBAAgB,gBAAuC;AACzD,QAAI,CAAC,KAAK,cAAc,IAAI,cAAc,GAAG;AACzC,WAAK,cAAc,IAAI,gBAAgB,EAAE,gBAAgB,SAAS,CAAC,EAAE,CAAC;AAAA,IAC1E;AAAA,EACJ;AAAA,EAEA,MAAM,gBAAgB,gBAA+C;AACjE,WAAO,KAAK,cAAc,IAAI,cAAc;AAAA,EAChD;AAAA,EAEA,MAAM,gBAAgB,gBAA0C;AAC5D,WAAO,KAAK,cAAc,IAAI,cAAc;AAAA,EAChD;AAAA,EAEA,MAAM,mBAAmB,gBAAuC;AAC5D,SAAK,cAAc,OAAO,cAAc;AAAA,EAC5C;AAAA,EAEA,MAAM,uBAAuB,gBAAwB,OAA+B;AAChF,UAAM,eAAe,MAAM,KAAK,gBAAgB,cAAc;AAC9D,iBAAa,QAAQ,KAAK,KAAK;AAAA,EACnC;AAAA,EAEA,MAAM,qBAAoC;AACtC,SAAK,cAAc,MAAM;AAAA,EAC7B;AACJ;;;ADvFO,IAAM,wBAAN,MAA4B;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,cAAc;AACV,SAAK,UAAU,CAAC;AAChB,SAAK,cAAc;AACnB,SAAK,oBAAoB;AACzB,SAAK;AAEL,SAAK,gBAAgB;AAAA;AAAA;AAAA;AAKrB,SAAK,oCAAoC;AACzC,SAAK,2BAA2B;AAChC,SAAK,QAAQ,IAAI,YAAY;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,QAAQ;AACV,UAAM,SAAS,IAAI,eAAe,IAAI;AACtC,UAAM,OAAO,KAAK,IAAI;AACtB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,kBAAkB,gBAAoC;AAClD,SAAK,iBAAiB;AACtB,WAAO;AAAA,EACX;AAAA,EAEA,kBAAkB,gBAAgC;AAC9C,SAAK,iBAAiB;AACtB,WAAO;AAAA,EACX;AAAA,EAEA,SAAS,OAA+C;AACpD,QAAI,OAAO,UAAU;AAAU,WAAK,QAAQ;AAAA,SACvC;AACD,UAAI,UAAU;AAAY,aAAK,QAAQ;AAAA;AAClC,aAAK,QAAQ;AAAA,IACtB;AAEA,WAAO;AAAA,EACX;AAAA,EAEA,SAAS,OAAkB;AACvB,SAAK,QAAQ;AACb,WAAO;AAAA,EACX;AAAA,EAEA,eAAe,aAAqB;AAChC,SAAK,cAAc;AACnB,QAAI,KAAK;AAAO,WAAK,SAAS,KAAK,KAAK;AACxC,WAAO;AAAA,EACX;AAAA,EAEA,iBAAiB,eAAuB;AACpC,SAAK,gBAAgB;AACrB,WAAO;AAAA,EACX;AAAA,EAEA,4BAA4B,0BAAkC;AAC1D,SAAK,2BAA2B;AAChC,WAAO;AAAA,EACX;AAAA,EAEA,UAAU,QAAoB;AAC1B,SAAK,QAAQ,KAAK,MAAM;AACxB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,qBAAqB,mBAA2B;AAC5C,SAAK,oBAAoB;AACzB,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,0CAA0C,mCAA4C;AAClF,SAAK,oCAAoC;AACzC,WAAO;AAAA,EACX;AAAA,EAEA,aAAa;AACT,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,uBAAuB;AACnB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,oBAAoB;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,iBAAiB;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,8BAA8B;AAC1B,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,mBAAmB;AACf,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,oBAAoB;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,WAAW;AACP,WAAO,KAAK;AAAA,EAChB;AAAA,EAEA,4CAA4C;AACxC,WAAO,KAAK;AAAA,EAChB;AACJ;;;AEhKA,SAAS,mBAAmB;AAC5B,OAAOC,0BAAyB;AAGhC,OAAOC,UAAS;;;ACJhB,OAAO,UAAU;AACjB,OAAOC,0BAAyB;;;ACEhC;AACAC;AAJA,SAAS,sCAAsC;AAC/C,OAAOC,UAAS;;;AFMhB;;;AGPA;AACAC;AACA,OAAOC,UAAS;;;ACEhBC;AACA;AALA,SAAS,eAAAC,oBAAmB;AAC5B,OAAOC,0BAAyB;AAChC,OAAOC,UAAS;;;ACIhB;;;ACFAC;AAJA,OAAOC,2BAAyB;AAChC,SAAiB,oBAAoB;AAK9B,IAAM,WAAN,MAA6C;AAAA,EAC/B,QAAQA,sBAAoB,yBAAyB;AAAA,EACrD;AAAA,EACA;AAAA,EAEjB,YAAY,EAAE,MAAAC,OAAM,UAAU,GAAyC;AACnE,SAAK,YAAY,aAAa;AAC9B,SAAK,SAAS,aAAa;AAAA,MACvB,KAAK,QAAQA,KAAI;AAAA,IACrB,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,KAAK,EAAE,WAAW,GAA2B;AAC/C,UAAM,KAAK,OAAO,QAAQ,8BAA8B,KAAK,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,uCAKvC,UAAU;AAAA;AAAA,WAEtC;AAAA,EACP;AAAA,EAEA,MAAM,aAAa,QAA4C;AAC3D,UAAM,QAAQ,OAAO,IAAI,CAAC,UAAU;AAChC,aAAO;AAAA,QACH,KAAK,yBAAyB,KAAK,SAAS;AAAA,6CACf,MAAM,OAAO,KAAK,GAAG,CAAC;AAAA,QACnD,MAAM;AAAA,UACF,MAAM,SAAS;AAAA,UACf,MAAM;AAAA,UACN,MAAM,SAAS;AAAA,UACf,MAAM,SAAS;AAAA,UACf,KAAK,UAAU,MAAM,QAAQ;AAAA,QACjC;AAAA,MACJ;AAAA,IACJ,CAAC;AAED,SAAK,MAAM,qBAAqB,qBAAqB,KAAK,UAAU,KAAK,GAAG,GAAI,CAAC,EAAE;AACnF,UAAM,SAAS,MAAM,KAAK,OAAO,MAAM,OAAO,OAAO;AACrD,WAAO,OAAO,OAAO,CAAC,GAAG,MAAM,IAAI,EAAE,cAAc,CAAC;AAAA,EACxD;AAAA,EAEA,MAAM,iBAAiB,OAAiB,GAAW,UAAgD;AAC/F,QAAI,YAAY;AAAA,yDACiC,MAAM,KAAK,GAAG,CAAC;AAAA,mBACrD,KAAK,SAAS;AAAA,8DAC6B,MAAM,KAAK,GAAG,CAAC;AAAA,oBACzD,CAAC;AAEb,QAAI,UAAU;AACV,kBAAY;AAAA;AAAA;AAAA,wDAGgC,MAAM,KAAK,GAAG,CAAC;AAAA;AAAA,uBAEhD,KAAK,SAAS;AAAA;AAAA;AAAA,eAGtB,KAAK,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,uBAKN,QAAQ;AAAA;AAAA,YAEnB,CAAC;AAAA;AAAA,IAEL;AAEA,SAAK,MAAM,yBAAyB,qBAAqB,WAAW,GAAG,CAAC,EAAE;AAC1E,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ,SAAS;AAEnD,WAAO,QAAQ,KAAK,IAAI,CAAC,WAAW;AAChC,YAAM,WAAW,KAAK,MAAM,OAAO,SAAS,SAAS,CAAC;AAEtD,aAAO;AAAA,QACH;AAAA,QACA,aAAa,OAAO,YAAY,SAAS;AAAA,QACzC,OAAO,IAAY,OAAO;AAAA,MAC9B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,iBAAkC;AACpC,UAAM,YAAY,kCAAkC,KAAK,SAAS;AAElE,SAAK,MAAM,yBAAyB,SAAS,EAAE;AAC/C,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ,SAAS;AAEnD,WAAO,OAAO,SAAS,QAAQ,KAAK,CAAC,EAAE,MAAM,SAAS,CAAC;AAAA,EAC3D;AAAA,EAEA,MAAM,WAAW,gBAA0C;AACvD,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,SAAS;AAAA,+BAChC,cAAc,IAAI;AACzC,WAAO;AAAA,EACX;AAAA,EAEA,MAAM,QAAuB;AACzB,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,SAAS,GAAG;AAAA,EAC9D;AACJ;;;AC5GA,OAAOC,2BAAyB;AAChC,SAAiB,gBAAAC,qBAAoB;AAG9B,IAAM,cAAN,MAAuC;AAAA,EACzB,QAAQD,sBAAoB,2BAA2B;AAAA,EACvD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEjB,YAAY;AAAA,IACR,MAAAE;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAKG;AACC,SAAK,6BAA6B,8BAA8B;AAChE,SAAK,yBAAyB,0BAA0B;AACxD,SAAK,mBAAmB,oBAAoB;AAC5C,SAAK,SAASD,cAAa;AAAA,MACvB,KAAK,QAAQC,KAAI;AAAA,IACrB,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,OAAsB;AACxB,SAAK,MAAM,mBAAmB,KAAK,sBAAsB,GAAG;AAC5D,UAAM,KAAK,OAAO,QAAQ,8BAA8B,KAAK,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBASpE,KAAK,sBAAsB,aAAa,KAAK,sBAAsB,oBAAoB;AACtG,SAAK,MAAM,kBAAkB,KAAK,sBAAsB,uBAAuB;AAE/E,SAAK,MAAM,mBAAmB,KAAK,gBAAgB,GAAG;AACtD,UAAM,KAAK,OAAO,QAAQ,8BAA8B,KAAK,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA,WAK1E;AACH,SAAK,MAAM,kBAAkB,KAAK,gBAAgB,GAAG;AAErD,SAAK,MAAM,mBAAmB,KAAK,0BAA0B,GAAG;AAChE,UAAM,KAAK,OAAO,QAAQ,8BAA8B,KAAK,0BAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,uBAMxE,KAAK,0BAA0B,aAAa,KAAK,0BAA0B,cAAc;AACxG,SAAK,MAAM,kBAAkB,KAAK,0BAA0B,uBAAuB;AAAA,EACvF;AAAA,EAEA,MAAM,kBAAkB,UAAkB,OAAuC;AAC7E,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,gBAAgB,gBAAgB,QAAQ,IAAI;AAE1F,UAAM,KAAK,OAAO,QAAQ;AAAA,MACtB,KAAK,eAAe,KAAK,gBAAgB;AAAA;AAAA,MAEzC,MAAM,CAAC,UAAU,MAAM,MAAM,MAAM,iBAAiB,KAAK,UAAU,MAAM,cAAc,CAAC;AAAA,IAC5F,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,kBAAkB,UAA4C;AAChE,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,+CAA+C,KAAK,gBAAgB;AAAA,MACzE,MAAM,CAAC,QAAQ;AAAA,IACnB,CAAC;AAED,UAAM,SAAS,QAAQ,KAAK,CAAC;AAC7B,UAAM,WAAW,KAAK,MAAM,OAAO,SAAS,SAAS,CAAC;AAEtD,WAAO;AAAA,MACH,UAAU;AAAA,MACV,gBAAgB;AAAA,MAChB,iBAAiB,OAAO,SAAS,OAAO,gBAAgB,SAAS,CAAC;AAAA,MAClE,MAAM,OAAO,KAAK,SAAS;AAAA,IAC/B;AAAA,EACJ;AAAA,EAEA,MAAM,kBAAkB,UAAoC;AACxD,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,+CAA+C,KAAK,gBAAgB;AAAA,MACzE,MAAM,CAAC,QAAQ;AAAA,IACnB,CAAC;AAED,WAAO,QAAQ,KAAK,SAAS;AAAA,EACjC;AAAA,EAEA,MAAM,uBAAmD;AACrD,UAAM,UAAU,MAAM,KAAK,OAAO;AAAA,MAC9B,mDAAmD,KAAK,gBAAgB;AAAA,IAC5E;AAEA,WAAO,QAAQ,KAAK,IAAI,CAAC,WAAW;AAChC,YAAM,WAAW,KAAK,MAAM,OAAO,SAAS,SAAS,CAAC;AAEtD,aAAO;AAAA,QACH,UAAU,OAAO,GAAG,SAAS;AAAA,QAC7B,gBAAgB;AAAA,QAChB,iBAAiB,OAAO,SAAS,OAAO,gBAAgB,SAAS,CAAC;AAAA,QAClE,MAAM,OAAO,KAAK,SAAS;AAAA,MAC/B;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,MAAM,gBAAmD,UAAkB,KAAa,OAAyB;AAC7G,SAAK,MAAM,sBAAsB,GAAG,iBAAiB,KAAK;AAC1D,UAAM,KAAK,mBAAmB,GAAG;AAEjC,SAAK,MAAM,sBAAsB,GAAG,kBAAkB;AACtD,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,eAAe,KAAK,0BAA0B;AAAA;AAAA,MAEnD,MAAM,CAAC,KAAK,UAAU,KAAK,UAAU,KAAK,CAAC;AAAA,IAC/C,CAAC;AAED,SAAK,MAAM,8BAA8B,GAAG,iBAAiB,QAAQ,IAAI;AAAA,EAC7E;AAAA,EAEA,MAAM,gBAAmD,KAAyB;AAC9E,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,qBAAqB,KAAK,0BAA0B;AAAA,MACzD,MAAM,CAAC,GAAG;AAAA,IACd,CAAC;AAED,WAAO,KAAK,MAAM,QAAQ,KAAK,CAAC,EAAE,MAAM,SAAS,CAAC;AAAA,EACtD;AAAA,EAEA,MAAM,gBAAgB,KAA+B;AACjD,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,qBAAqB,KAAK,0BAA0B;AAAA,MACzD,MAAM,CAAC,GAAG;AAAA,IACd,CAAC;AAED,WAAO,QAAQ,KAAK,SAAS;AAAA,EACjC;AAAA,EAEA,MAAM,mBAAmB,KAA4B;AACjD,SAAK,MAAM,yBAAyB,GAAG,GAAG;AAC1C,UAAM,UAAU,MAAM,KAAK,OAAO;AAAA,MAC9B,eAAe,KAAK,0BAA0B,iBAAiB,GAAG;AAAA,IACtE;AACA,SAAK,MAAM,iCAAiC,GAAG,iBAAiB,QAAQ,YAAY;AAAA,EACxF;AAAA,EAEA,MAAM,oCAAoC,UAAiC;AACvE,SAAK,MAAM,0DAA0D,QAAQ,GAAG;AAChF,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,gBAAgB,gBAAgB,QAAQ,IAAI;AAC1F,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,0BAA0B,sBAAsB,QAAQ,IAAI;AAAA,EAC9G;AAAA,EAEA,MAAM,gBAAgB,gBAA+C;AACjE,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,sEAAsE,KAAK,sBAAsB;AAAA,MACtG,MAAM,CAAC,cAAc;AAAA,IACzB,CAAC;AAED,WAAO;AAAA,MACH;AAAA,MACA,SAAS,QAAQ,KAAK,IAAI,CAAC,WAAW;AAClC,cAAM,YAAY,IAAI,KAAK,OAAO,UAAU,SAAS,CAAC;AACtD,cAAM,QAAQ,OAAO,MAAM,SAAS;AAEpC,YAAI,UAAU,MAAM;AAChB,iBAAO;AAAA,YACH,OAAO;AAAA,YACP,IAAI,OAAO,GAAG,SAAS;AAAA,YACvB,SAAS,OAAO,QAAQ,SAAS;AAAA,YACjC,SAAS,KAAK,MAAM,OAAO,QAAQ,SAAS,CAAC;AAAA,YAC7C;AAAA,UACJ;AAAA,QACJ,OAAO;AACH,iBAAO;AAAA,YACH,IAAI,OAAO,GAAG,SAAS;AAAA,YACvB,SAAS,OAAO,QAAQ,SAAS;AAAA,YACjC;AAAA,YACA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAEA,MAAM,gBAAgB,gBAA0C;AAC5D,UAAM,UAAU,MAAM,KAAK,OAAO,QAAQ;AAAA,MACtC,KAAK,6DAA6D,KAAK,sBAAsB;AAAA,MAC7F,MAAM,CAAC,cAAc;AAAA,IACzB,CAAC;AAED,WAAO,QAAQ,KAAK,SAAS;AAAA,EACjC;AAAA,EAEA,MAAM,mBAAmB,gBAAuC;AAC5D,UAAM,KAAK,OAAO;AAAA,MACd,eAAe,KAAK,sBAAsB,4BAA4B,cAAc;AAAA,IACxF;AAAA,EACJ;AAAA,EAEA,MAAM,uBAAuB,gBAAwB,OAA+B;AAChF,QAAI,MAAM,UAAU,MAAM;AACtB,YAAM,KAAK,OAAO,QAAQ;AAAA,QACtB,KAAK,yBAAyB,KAAK,sBAAsB;AAAA;AAAA,QAEzD,MAAM,CAAC,MAAM,IAAI,gBAAgB,MAAM,SAAS,MAAM,WAAW,MAAM,KAAK;AAAA,MAChF,CAAC;AAAA,IACL,OAAO;AACH,YAAM,KAAK,OAAO,QAAQ;AAAA,QACtB,KAAK,yBAAyB,KAAK,sBAAsB;AAAA;AAAA,QAEzD,MAAM;AAAA,UACF,MAAM;AAAA,UACN;AAAA,UACA,MAAM;AAAA,UACN,MAAM;AAAA,UACN,MAAM;AAAA,UACN,KAAK,UAAU,MAAM,OAAO;AAAA,QAChC;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EAEA,MAAM,qBAAoC;AACtC,UAAM,KAAK,OAAO,QAAQ,eAAe,KAAK,sBAAsB,GAAG;AAAA,EAC3E;AAAA,EAEA,MAAM,gBAAgB,iBAAwC;AAAA,EAE9D;AACJ;;;AX5OAC;;;AYAA;AACAC;AALA,SAAS,wBAAwB;AACjC,OAAOC,2BAAyB;AAChC,OAAOC,UAAS;AAKT,IAAM,mBAAN,cAA+B,WAA8D;AAAA,EAC/E,QAAQD,sBAAoB,iCAAiC;AAAA,EAE7D;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EAEjB,YAAY;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GAUG;AACC,UAAM,oBAAoBC,KAAI,SAAS,CAAC,IAAI,EAAE,UAAU,GAAG,aAAa,KAAM,gBAAgB,GAAG;AAEjG,SAAK,YAAY;AACjB,SAAK,oBAAoB,qBAAqB,QAAQ,IAAI;AAC1D,SAAK,oBAAoB,eAAe,qBAAqB;AAE7D,SAAK,aAAa,IAAI,iBAAiB;AAAA,MACnC,MAAM,KAAK;AAAA,MACX,gBAAgB;AAAA,QACZ,OAAO;AAAA,UACH,UAAU,sBAAsB,QAAQ,IAAI;AAAA,UAC5C,UAAU,mBAAmB,QAAQ,IAAI;AAAA,QAC7C;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EAEA,OAAgB,sBAAsB;AAClC,QAAI,QAAQ;AACZ,qBAAiB,UAAU,KAAK,aAAa,KAAK,SAAS,GAAG;AAC1D,YAAM;AACN;AAAA,IACJ;AAEA,SAAK,MAAM,UAAU,KAAK,SAAS,SAAS,KAAK,YAAY;AAAA,EACjE;AAAA,EAEA,OAAe,aAAa,UAAkB;AAC1C,SAAK,MAAM,oBAAoB,QAAQ;AAEvC,QAAI;AACA,YAAM,eAAe,MAAM,KAAK,WAAW,MAAM,mBAAmB,EAAE,SAAS,CAAC;AAChF,WAAK,MAAM,qBAAqB,QAAQ,UAAU,aAAa,MAAM,EAAE,QAAQ,MAAM,cAAc;AAEnG,iBAAW,EAAE,IAAI,MAAM,KAAK,aAAa,MAAM,EAAE,SAAS;AACtD,yBAAiB,UAAU,KAAK,YAAY,IAAI,KAAK,GAAG;AACpD,gBAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,WAAK,MAAM,+BAA+B,UAAU,CAAC;AACrD;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,OAAe,YAAY,QAAgB,OAAe;AACtD,SAAK,MAAM,mBAAmB,KAAK;AACnC,QAAI,oBAAoB;AAExB,QAAI;AACA,YAAM,iBAAiB,MAAM,KAAK,WAAW,QAAQ,eAAe;AAAA,QAChE,IAAI;AAAA,QACJ,QAAQ,CAAC,WAAW,SAAS;AAAA,MACjC,CAAC;AAED,UAAI,KAAK,mBAAmB;AACxB,cAAM,mBAAmB,IAAI,KAAK,eAAe,QAAQ,YAAY,IAAI;AAEzE,YAAI,mBAAmB,KAAK,mBAAmB;AAC3C,eAAK,MAAM,SAAS,KAAK,wBAAwB,gBAAgB,iBAAiB;AAAA,QACtF,OAAO;AACH,eAAK;AAAA,YACD,SAAS,KAAK,wBAAwB,gBAAgB;AAAA,UAC1D;AACA;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,eAAe,QAAQ;AAAQ,cAAM,IAAI,MAAM,gDAAgD;AACpG,0BAAoB,eAAe,QAAQ;AAAA,IAC/C,SAAS,GAAG;AACR,WAAK,MAAM,wDAAwD,OAAO,EAAE,QAAQ;AACpF;AAAA,IACJ;AAEA,QAAI,YAAY;AAChB,QAAI,CAAE,MAAM,KAAK,aAAa,MAAM,GAAI;AACpC,WAAK,MAAM,eAAe,KAAK,yBAAyB;AACxD,kBAAY;AAAA,IAChB,OAAO;AACH,YAAM,gBAAgB,MAAM,KAAK,aAAa,MAAM,GAAG;AACvD,UAAI,iBAAiB,mBAAmB;AACpC,aAAK;AAAA,UACD,aAAa,KAAK,2BAA2B,YAAY,8BAA8B,iBAAiB;AAAA,QAC5G;AACA,oBAAY;AAAA,MAChB;AACI,aAAK;AAAA,UACD,aAAa,KAAK,oDAAoD,iBAAiB;AAAA,QAC3F;AAAA,IACR;AAEA,QAAI,CAAC,WAAW;AACZ,WAAK,MAAM,kBAAkB,KAAK,GAAG;AACrC;AAAA,IACJ;AAEA,QAAI;AACA,YAAM,UAAU,MAAM,KAAK,WAAW,QAAQ,eAAe;AAAA,QACzD,IAAI;AAAA,QACJ,QAAQ,CAAC,QAAQ,iBAAiB,WAAW;AAAA,MACjD,CAAC;AAED,UAAI,CAAC,QAAQ,KAAK,KAAK,OAAO;AAC1B,aAAK,MAAM,SAAS,MAAM,kCAAkC;AAC5D;AAAA,MACJ;AAEA,WAAK,MAAM,gCAAgC,KAAK,MAAM;AACtD,uBAAiB,UAAU,KAAK,iBAAiB,QAAQ,KAAK,KAAK,OAAO,QAAQ,OAAO,KAAK,GAAG;AAC7F,cAAM;AAAA,MACV;AAEA,YAAM,KAAK,YAAY,QAAQ,EAAE,SAAS,kBAAkB,CAAC;AAE7D,UAAI,QAAQ,UAAU;AAClB,mBAAW,EAAE,IAAI,OAAAC,OAAM,KAAK,QAAQ,SAAS,KAAK,SAAS;AACvD,cAAI;AACA,6BAAiB,UAAU,KAAK,YAAY,IAAIA,MAAK,GAAG;AACpD,oBAAM;AAAA,YACV;AAAA,UACJ,SAAS,GAAG;AACR,iBAAK,MAAM,wCAAwCA,MAAK,KAAK,QAAQ,CAAC;AACtE;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,SAAS,GAAG;AACR,WAAK,MAAM,yCAAyC,QAAQ,CAAC;AAC7D;AAAA,IACJ;AAAA,EACJ;AAAA,EAEA,OAAe,iBAAiB,UAAkB,SAAiB;AAC/D,UAAM,YAAY,IAAI,UAAU;AAAA,MAC5B,cAAc;AAAA,MACd,WAAW,KAAK;AAAA,MAChB,cAAc,KAAK;AAAA,IACvB,CAAC;AAED,qBAAiB,UAAU,MAAM,UAAU,oBAAoB,GAAG;AAG9D,aAAO,cAAc,OAAO,YAAY,QAAQ,mBAAmB,EAAE;AAErE,YAAM;AAAA,QACF,aAAa,OAAO;AAAA,QACpB,UAAU;AAAA,UACN,MAAM;AAAA,UACN,QAAQ,GAAG,KAAK,iBAAiB,QAAQ,OAAO;AAAA,QACpD;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AZtLA,IAAM,eAAe,KAAK,QAAQ,+BAA+B;AACjE,IAAM,iBAAiB,MAAM,IAAI,sBAAsB,EAClD,SAAS,IAAI,YAAY,EAAE,MAAM,aAAa,CAAC,CAAC,EAChD,kBAAkB,IAAI,SAAS,EAAE,MAAM,aAAa,CAAC,CAAC,EACtD,SAAS,IAAI,OAAO,EAAE,WAAW,SAAS,CAAC,CAAC,EAC5C,kBAAkB,IAAI,iBAAiB,CAAC,EACxC,MAAM;AAEX,MAAM,eAAe,UAAU,IAAI,iBAAiB,EAAE,WAAW,OAAO,CAAC,CAAC;AAC1E,QAAQ,IAAI,MAAM,eAAe,MAAM,oBAAoB,CAAC;",
  "names": ["createDebugMessages", "createDebugMessages", "init_src", "createDebugMessages", "createDebugMessages", "init_src", "RecursiveCharacterTextSplitter", "createDebugMessages", "md5", "init_src", "init_src", "init_src", "createDebugMessages", "OpenAi", "createDebugMessages", "md5", "createDebugMessages", "init_src", "md5", "init_src", "md5", "init_src", "getMimeType", "createDebugMessages", "md5", "init_src", "createDebugMessages", "path", "createDebugMessages", "createClient", "path", "init_src", "init_src", "createDebugMessages", "md5", "title"]
}
